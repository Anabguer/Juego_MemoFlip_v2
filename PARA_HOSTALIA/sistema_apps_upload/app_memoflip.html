<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MemoFlip - Juego de Memoria</title>
    <style>
        :root {
            --bg: #0b132b;
            --ink: #eef;
            --panel: #111a33;
            --accent: #ffd447;
            --ok: #2a9d8f;
            --error: #e63946;
            --muted: #2a355f;
            --veil: rgba(255,255,255,.15);
            --path: #8da9c4;
            --node: #ffd447;
            --nodeb: #caa435;
            --hud: #16213e;
        }

        /* Temas por cap√≠tulo */
        .theme-1 { --bg: #0b132b; --panel: #111a33; --hud: #16213e; --path: #8da9c4; --node: #ffd447; --nodeb: #caa435; } /* Oc√©ano */
        .theme-2 { --bg: #1b2a17; --panel: #253422; --hud: #2b4127; --path: #a5c59a; --node: #f1d86a; --nodeb: #b7a34a; } /* Isla */
        .theme-3 { --bg: #2b0b0b; --panel: #3a1414; --hud: #451919; --path: #d8a5a5; --node: #ff8f47; --nodeb: #c56b33; } /* Volc√°n */
        .theme-4 { --bg: #0b162b; --panel: #10203d; --hud: #12264a; --path: #9db7e6; --node: #70d6ff; --nodeb: #53a7c0; } /* Cielo */
        .theme-5 { --bg: #221b2b; --panel: #2e2436; --hud: #372d42; --path: #c3a9d6; --node: #da77f2; --nodeb: #a85dc0; } /* Noche */

        * { box-sizing: border-box; }
        html, body { margin: 0; height: 100%; background: var(--bg); color: var(--ink); font-family: 'Segoe UI', Arial, sans-serif; }
        
        /* Header global */
        header {
            padding: .6rem 1rem;
            background: var(--panel);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,.3);
        }
        
        .logo { font-weight: 900; font-size: 1.4rem; color: var(--accent); }
        .header-right { display: flex; gap: 1rem; align-items: center; }
        .coins { display: flex; align-items: center; gap: .3rem; font-weight: bold; }
        .lives { display: flex; align-items: center; gap: .3rem; }
        .sound-btn { background: none; border: none; font-size: 1.2rem; cursor: pointer; }
        
        /* Botones */
        .btn {
            background: linear-gradient(145deg, #1c2541, #0f1a33);
            border: 1px solid var(--muted);
            color: var(--ink);
            padding: .6rem 1.2rem;
            border-radius: .7rem;
            cursor: pointer;
            font-weight: 600;
            transition: all .2s;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        .btn:hover { background: linear-gradient(145deg, #223355, #1a2644); transform: translateY(-1px); }
        .btn:disabled { opacity: .5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(145deg, var(--accent), #caa435); color: #222; }
        .btn-primary:hover { background: linear-gradient(145deg, #ffdc3a, #b8932f); }
        .btn-success { background: linear-gradient(145deg, var(--ok), #228b7a); }
        .btn-danger { background: linear-gradient(145deg, var(--error), #cc2936); }
        
        /* Pantallas */
        .screen { display: none; min-height: calc(100vh - 60px); }
        .screen.active { display: block; }
        
        main { height: calc(100vh - 60px); }
        .hidden { display: none !important; }
        
        /* Pantalla de inicio */
        #startScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
            background: radial-gradient(circle at center, var(--panel), var(--bg));
        }
        
        .start-logo {
            font-size: 3rem;
            font-weight: 900;
            color: var(--accent);
            margin-bottom: .5rem;
            text-shadow: 0 4px 8px rgba(0,0,0,.5);
        }
        
        .start-subtitle {
            font-size: 1.2rem;
            margin-bottom: 3rem;
            opacity: .8;
        }
        
        .start-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 250px;
        }
        
        /* Pantalla de mapa */
        #mapScreen {
            position: relative;
            height: 100%;
            overflow: auto;
            background: radial-gradient(120% 80% at 50% 20%, #13315c, var(--bg));
            transition: transform .25s ease;
        }
        
        #mapWrap {
            position: relative;
            width: 100%;
            min-height: 100%;
            padding: 2rem 0;
        }
        
        .map-hud {
            position: sticky;
            top: 0;
            padding: .8rem 1rem;
            background: var(--hud);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: .8rem;
            flex-wrap: wrap;
            z-index: 50;
            box-shadow: 0 2px 8px rgba(0,0,0,.3);
        }
        
        .map-title {
            font-weight: 900;
            font-size: clamp(16px, 4vw, 22px);
        }
        
        .map-nav {
            display: flex;
            gap: .5rem;
        }
        
        .nav-btn {
            background: var(--panel);
            border: 1px solid var(--muted);
            color: var(--ink);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
        }
        
        .nav-btn:disabled { opacity: .4; cursor: not-allowed; }
        
        /* Nodos del mapa */
        #mapContainer {
            position: relative;
            width: 100%;
            min-height: 800px;
            padding: 2rem;
        }
        
        .node {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 54px;
            height: 54px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-weight: bold;
            background: var(--node);
            color: #222;
            border: 2px solid var(--nodeb);
            box-shadow: 0 6px 0 var(--nodeb);
            cursor: pointer;
            transition: all .2s;
        }
        
        .node:hover { transform: translate(-50%, -50%) scale(1.1); }
        .node.locked { filter: grayscale(.85); opacity: .6; box-shadow: none; cursor: not-allowed; }
        .node.current { outline: 4px solid #5bc0be; outline-offset: 2px; animation: pulse 2s infinite; }
        .node.completed { background: var(--ok); border-color: #228b7a; }
        
        .node.boss {
            width: 68px;
            height: 68px;
            background: linear-gradient(180deg, var(--node), #fff2b5);
            box-shadow: 0 10px 0 var(--nodeb), 0 0 24px rgba(255,212,71,.5);
        }
        
        .node.boss::after {
            content: "üëë";
            position: absolute;
            top: -18px;
            font-size: 18px;
        }
        
        .node .icons {
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            display: flex;
            gap: 1px;
        }
        
        .node .label {
            position: absolute;
            bottom: -26px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: .6px;
            opacity: .9;
        }
        
        /* L√≠nea de conexi√≥n */
        #pathSvg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .path-line {
            stroke: var(--path);
            stroke-width: 3;
            fill: none;
            opacity: .6;
        }
        
        /* Pantalla de juego */
        #gameScreen {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .game-hud {
            padding: .8rem 1rem;
            background: var(--hud);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .level-info {
            display: flex;
            align-items: center;
            gap: .5rem;
        }
        
        .level-number {
            font-weight: 900;
            font-size: 1.2rem;
        }
        
        .mechanics-icons {
            display: flex;
            gap: .2rem;
        }
        
        .game-stats {
            display: flex;
            gap: 1rem;
            font-size: .9rem;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: .3rem;
        }
        
        .timer-bar {
            position: relative;
            height: 6px;
            background: rgba(0,0,0,.3);
            border-radius: 3px;
            overflow: hidden;
            flex: 1;
            min-width: 150px;
        }
        
        .timer-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--ok), var(--accent), var(--error));
            transition: width .1s linear;
        }
        
        /* Grid de cartas */
        .game-area {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .cards-grid {
            display: grid;
            gap: .5rem;
            max-width: 100%;
            width: fit-content;
        }
        
        .card {
            aspect-ratio: 3/4;
            background: linear-gradient(145deg, #243b55, #1a2d44);
            border: 2px solid #3b5b8a;
            border-radius: .8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #fff;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all .3s ease;
            user-select: none;
            min-width: 60px;
            min-height: 80px;
        }
        
        .card:hover { transform: scale(1.05); }
        .card.flipped { background: linear-gradient(145deg, #fff, #f0f0f0); color: #333; border-color: var(--accent); }
        .card.matched { background: linear-gradient(145deg, var(--ok), #228b7a); border-color: var(--ok); }
        .card.wrong { background: linear-gradient(145deg, var(--error), #cc2936); animation: shake .5s; }
        .card.special { border-color: var(--accent); box-shadow: 0 0 12px rgba(255,212,71,.4); }
        
        /* Efectos especiales */
        .card.fog { opacity: .3; }
        .card.ghost { opacity: .7; animation: ghostly 1s ease-in-out infinite alternate; }
        .card.mirror { transform: scaleX(-1); }
        .card.trap { filter: grayscale(1); }
        
        /* Modales */
        .modal {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0,0,0,.7);
            z-index: 200;
            backdrop-filter: blur(4px);
        }
        
        .modal.hidden { display: none !important; }
        
        .modal-box {
            background: linear-gradient(145deg, var(--panel), var(--bg));
            border: 2px solid var(--muted);
            border-radius: 1rem;
            padding: 2rem;
            min-width: 300px;
            max-width: 90vw;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,.5);
        }
        
        .modal-title {
            font-size: 1.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            color: var(--accent);
        }
        
        .modal-content {
            margin-bottom: 2rem;
            line-height: 1.5;
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .score-breakdown {
            background: rgba(0,0,0,.2);
            border-radius: .5rem;
            padding: 1rem;
            margin: 1rem 0;
            text-align: left;
        }
        
        .score-line {
            display: flex;
            justify-content: space-between;
            margin: .3rem 0;
        }
        
        .score-total {
            border-top: 1px solid var(--muted);
            padding-top: .5rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            header { padding: .4rem .8rem; }
            .header-right { gap: .5rem; }
            .logo { font-size: 1.2rem; }
            .coins, .lives { font-size: .9rem; }
            
            .game-hud { padding: .6rem .8rem; flex-direction: column; gap: .5rem; }
            .game-stats { gap: .8rem; }
            
            .cards-grid { gap: .3rem; }
            .card { min-width: 50px; min-height: 67px; font-size: 1.5rem; }
            
            .modal-box { padding: 1.5rem; min-width: 280px; }
            .modal-buttons { flex-direction: column; }
        }
        
        /* Animaciones */
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes ghostly {
            from { opacity: .3; }
            to { opacity: .8; }
        }
        
        @keyframes flipIn {
            from { transform: rotateY(-90deg); }
            to { transform: rotateY(0); }
        }
        
        .card.flip-animation { animation: flipIn .3s ease-out; }
        
        /* Grid responsivo para diferentes tama√±os */
        .grid-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-3 { grid-template-columns: repeat(3, 1fr); }
        .grid-4 { grid-template-columns: repeat(4, 1fr); }
        .grid-5 { grid-template-columns: repeat(5, 1fr); }
        .grid-6 { grid-template-columns: repeat(6, 1fr); }
        
        @media (max-width: 480px) {
            .grid-5, .grid-6 { grid-template-columns: repeat(4, 1fr); }
        }
        
        /* Efectos de part√≠culas */
        .particles {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 150;
        }
        
        .particle {
            position: absolute;
            font-size: 1.5rem;
            animation: particle-float 2s ease-out forwards;
        }
        
        @keyframes particle-float {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(0.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- Header global -->
    <header>
        <div class="logo">üéÆ MemoFlip</div>
        <div class="header-right">
            <div class="coins">
                <span>ü™ô</span>
                <span id="coinsDisplay">0</span>
            </div>
            <div class="lives">
                <span>‚ù§Ô∏è</span>
                <span id="livesDisplay">5</span>
            </div>
            <button class="sound-btn" id="soundToggle">üîä</button>
        </div>
    </header>

    <main>
        <!-- Pantalla de inicio -->
        <div id="startScreen" class="screen active">
            <div class="start-logo">üéÆ MemoFlip</div>
            <div class="start-subtitle">Juego de Memoria √âpico</div>
            <div class="start-buttons">
                <button class="btn btn-primary" onclick="startAsGuest()">üöÄ Jugar como Invitado</button>
                <button class="btn" onclick="showLogin()">üë§ Iniciar Sesi√≥n</button>
                <button class="btn" onclick="showRegister()">üìù Registrarse</button>
            </div>
        </div>

        <!-- Pantalla de mapa -->
        <div id="mapScreen" class="screen">
            <div class="map-hud">
                <div class="map-title">Cap√≠tulo <span id="currentChapter">1</span>: <span id="chapterName">Oc√©ano</span></div>
                <div class="map-nav">
                    <button class="nav-btn" id="prevChapterBtn" onclick="changeChapter(-1)">‚¨ÜÔ∏è</button>
                    <button class="nav-btn" id="nextChapterBtn" onclick="changeChapter(1)">‚¨áÔ∏è</button>
                </div>
            </div>
            <div id="mapWrap">
                <div id="mapContainer">
                    <svg id="pathSvg"></svg>
                    <!-- Los nodos se generan din√°micamente -->
                </div>
            </div>
        </div>

        <!-- Pantalla de juego -->
        <div id="gameScreen" class="screen">
            <div class="game-hud">
                <div class="level-info">
                    <div class="level-number">Nivel <span id="currentLevel">1</span></div>
                    <div class="mechanics-icons" id="mechanicsIcons"></div>
                </div>
                <div class="timer-bar hidden" id="timerBar">
                    <div class="timer-fill" id="timerFill"></div>
                </div>
                <div class="game-stats">
                    <div class="stat">
                        <span>‚è±Ô∏è</span>
                        <span id="timeDisplay">00:00</span>
                    </div>
                    <div class="stat">
                        <span>üëÜ</span>
                        <span id="movesDisplay">0</span>
                    </div>
                    <div class="stat">
                        <span>‚ùå</span>
                        <span id="failsDisplay">0</span>
                    </div>
                </div>
            </div>
            <div class="game-area">
                <div class="cards-grid" id="cardsGrid">
                    <!-- Las cartas se generan din√°micamente -->
                </div>
            </div>
        </div>
    </main>

    <!-- Contenedor de part√≠culas -->
    <div class="particles" id="particles"></div>

    <!-- Modal de victoria -->
    <div id="victoryModal" class="modal hidden">
        <div class="modal-box">
            <div class="modal-title">üéâ ¬°Victoria!</div>
            <div class="modal-content">
                <p>¬°Has completado el nivel <span id="victoryLevel">1</span>!</p>
                <div class="score-breakdown" id="scoreBreakdown">
                    <!-- Se llena din√°micamente -->
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="retryLevel()">üîÑ Reintentar</button>
                <button class="btn btn-primary" onclick="nextLevel()">‚û°Ô∏è Siguiente Nivel</button>
                <button class="btn" onclick="backToMap()">üó∫Ô∏è Mapa</button>
            </div>
        </div>
    </div>

    <!-- Modal de derrota -->
    <div id="defeatModal" class="modal hidden">
        <div class="modal-box">
            <div class="modal-title">üíî Game Over</div>
            <div class="modal-content">
                <p>¬°No has conseguido completar el nivel!</p>
                <p>Te quedan <span id="remainingLives">4</span> vidas.</p>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="retryLevel()">üîÑ Reintentar</button>
                <button class="btn" onclick="backToMap()">üó∫Ô∏è Volver al Mapa</button>
            </div>
        </div>
    </div>

    <!-- Modal de sin vidas -->
    <div id="noLivesModal" class="modal hidden">
        <div class="modal-box">
            <div class="modal-title">‚è∞ Sin Vidas</div>
            <div class="modal-content">
                <p>Te has quedado sin vidas.</p>
                <p>Regenerar√°s 1 vida cada hora.</p>
                <p>Pr√≥xima vida en: <span id="nextLifeTimer">59:59</span></p>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="backToMap()">üó∫Ô∏è Volver al Mapa</button>
            </div>
        </div>
    </div>

    <!-- Modal de pausa -->
    <div id="pauseModal" class="modal hidden">
        <div class="modal-box">
            <div class="modal-title">‚è∏Ô∏è Pausa</div>
            <div class="modal-content">
                <p>Juego pausado</p>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="resumeGame()">‚ñ∂Ô∏è Continuar</button>
                <button class="btn" onclick="retryLevel()">üîÑ Reiniciar</button>
                <button class="btn" onclick="backToMap()">üó∫Ô∏è Mapa</button>
            </div>
        </div>
    </div>

    <script>
        // =====================================
        // CONFIGURACI√ìN PARA HOSTALIA
        // =====================================
        
        const API_BASE = 'https://colisan.com/sistema_apps_upload/sistema_apps_api/memoflip/';
        const ASSETS_BASE = 'https://colisan.com/sistema_apps_upload/assets/memoflip/';
        
        // =====================================
        // CONFIGURACI√ìN Y DATOS GLOBALES
        // =====================================
        
        const MECHANICS_ICONS = {
            'crono': '‚è±Ô∏è',
            'niebla': 'üå´Ô∏è',
            'barajar': 'üîÄ',
            'triple': 'üî∫',
            'camaleon': 'üé≠',
            'trampa': 'üö´',
            'bomba': 'üí£',
            'comodin': 'üåü',
            'fantasma': 'üëª',
            'espejo': 'ü™û',
            'boss': 'üëë'
        };

        const CARD_EMOJIS = [
            'üê†', 'üêü', 'üê°', 'ü¶à', 'üêô', 'ü¶ë', 'üêö', '‚≠ê', 'üåä', 'üèùÔ∏è',
            'ü¶Ä', 'ü¶û', 'üê¢', 'üê≥', 'üêã', 'ü¶≠', 'üêß', 'ü¶Ü', '‚öì', 'üõ•Ô∏è',
            'üèñÔ∏è', 'üå∫', 'ü••', 'üçç', 'üå¥', 'ü¶©', 'ü¶ú', 'üêÖ', 'ü¶Å', 'üêò',
            'ü¶í', 'ü¶ì', 'ü¶è', 'üêä', 'üêç', 'ü¶é'
        ];

        let gameState = {
            currentUser: null,
            currentLevel: 1,
            maxLevelUnlocked: 1,
            coins: 0,
            lives: 5,
            soundEnabled: true,
            isPlaying: false,
            isPaused: false,
            isGuest: true,
            gameData: {
                pairs: 0,
                timeLimit: 0,
                timeUsed: 0,
                movesUsed: 0,
                fails: 0,
                mechanics: [],
                flippedCards: [],
                matchedCards: [],
                gameTimer: null,
                startTime: null
            }
        };

        let levelsData = [];
        let themesData = {};

        // =====================================
        // INICIALIZACI√ìN
        // =====================================

        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üéÆ Iniciando MemoFlip en Hostalia...');
            
            // Cargar datos del juego
            await loadGameData();
            
            // Cargar datos del usuario
            loadUserData();
            
            // Configurar eventos
            setupEventListeners();
            
            // Actualizar UI
            updateUI();
            
            console.log('‚úÖ MemoFlip iniciado correctamente');
        });

        async function loadGameData() {
            try {
                // Cargar niveles desde API
                const response = await fetch(API_BASE + 'game.php?action=levels');
                const result = await response.json();
                
                if (result.success) {
                    levelsData = result.levels;
                    console.log(`üìö Cargados ${levelsData.length} niveles desde API`);
                } else {
                    throw new Error(result.error || 'Error cargando niveles');
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error cargando desde API, usando datos locales:', error);
                // Datos de fallback
                levelsData = generateFallbackLevels();
            }
        }

        function generateFallbackLevels() {
            const levels = [];
            for (let i = 1; i <= 100; i++) {
                levels.push({
                    id: i,
                    pairs: Math.min(2 + Math.floor(i / 10), 12),
                    time_sec: i % 5 === 0 ? 60 + (i * 2) : 0,
                    tags: i % 10 === 0 ? ['boss'] : [],
                    note: i % 50 === 0 ? 'BOSS' : '',
                    chapter: Math.ceil(i / 50)
                });
            }
            return levels;
        }

        function loadUserData() {
            const savedData = localStorage.getItem('memoflip_user_hostalia');
            if (savedData) {
                const userData = JSON.parse(savedData);
                gameState.currentUser = userData.userKey || null;
                gameState.maxLevelUnlocked = userData.maxLevel || 1;
                gameState.coins = userData.coins || 0;
                gameState.lives = userData.lives || 5;
                gameState.soundEnabled = userData.soundEnabled !== false;
                gameState.isGuest = userData.isGuest !== false;
            }
        }

        function saveUserData() {
            const userData = {
                userKey: gameState.currentUser,
                maxLevel: gameState.maxLevelUnlocked,
                coins: gameState.coins,
                lives: gameState.lives,
                soundEnabled: gameState.soundEnabled,
                isGuest: gameState.isGuest,
                lastSave: Date.now()
            };
            localStorage.setItem('memoflip_user_hostalia', JSON.stringify(userData));
        }

        function setupEventListeners() {
            // Bot√≥n de sonido
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
            
            // Eventos de teclado
            document.addEventListener('keydown', handleKeyPress);
            
            // Prevenir zoom en m√≥viles
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        function handleKeyPress(e) {
            if (e.key === 'Escape') {
                if (gameState.isPlaying && !gameState.isPaused) {
                    pauseGame();
                }
            }
        }

        // =====================================
        // GESTI√ìN DE PANTALLAS
        // =====================================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        async function startAsGuest() {
            try {
                const response = await fetch(API_BASE + 'auth.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'guest' })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    gameState.currentUser = result.user_key;
                    gameState.isGuest = true;
                    gameState.maxLevelUnlocked = result.game_data.max_level_unlocked;
                    gameState.coins = result.game_data.coins_total;
                    gameState.lives = result.game_data.lives_current;
                    gameState.soundEnabled = result.game_data.sound_enabled;
                    
                    saveUserData();
                    updateUI();
                    showMap();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.warn('Error creando usuario invitado, usando modo offline:', error);
                gameState.currentUser = 'guest_offline_' + Date.now();
                gameState.isGuest = true;
                saveUserData();
                updateUI();
                showMap();
            }
        }

        function showLogin() {
            const email = prompt('Email:');
            const password = prompt('Contrase√±a:');
            
            if (!email || !password) return;
            
            loginUser(email, password);
        }

        function showRegister() {
            const email = prompt('Email:');
            const nombre = prompt('Nombre:');
            const password = prompt('Contrase√±a:');
            
            if (!email || !nombre || !password) return;
            
            registerUser(email, nombre, password);
        }

        async function loginUser(email, password) {
            try {
                const response = await fetch(API_BASE + 'auth.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: 'login',
                        email: email,
                        password: password
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    gameState.currentUser = result.user_key;
                    gameState.isGuest = false;
                    gameState.maxLevelUnlocked = result.game_data.max_level_unlocked;
                    gameState.coins = result.game_data.coins_total;
                    gameState.lives = result.game_data.lives_current;
                    gameState.soundEnabled = result.game_data.sound_enabled;
                    
                    saveUserData();
                    updateUI();
                    showMap();
                    showToast('‚úÖ Login exitoso');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('‚ùå Error en login: ' + error.message);
            }
        }

        async function registerUser(email, nombre, password) {
            try {
                const response = await fetch(API_BASE + 'auth.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: 'register',
                        email: email,
                        nombre: nombre,
                        password: password
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast('‚úÖ Usuario registrado correctamente');
                    loginUser(email, password);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('‚ùå Error en registro: ' + error.message);
            }
        }

        function showMap() {
            showScreen('mapScreen');
            generateMap();
            updateMapTheme();
        }

        // =====================================
        // GESTI√ìN DEL MAPA
        // =====================================

        function generateMap() {
            const mapContainer = document.getElementById('mapContainer');
            const pathSvg = document.getElementById('pathSvg');
            
            // Limpiar mapa anterior
            mapContainer.querySelectorAll('.node').forEach(node => node.remove());
            pathSvg.innerHTML = '';
            
            const currentChapter = Math.ceil(gameState.currentLevel / 50);
            const startLevel = (currentChapter - 1) * 50 + 1;
            const endLevel = Math.min(currentChapter * 50, levelsData.length);
            
            const nodes = [];
            const pathPoints = [];
            
            // Generar nodos en patr√≥n zig-zag
            for (let i = startLevel; i <= endLevel; i++) {
                const levelData = levelsData.find(l => l.id === i);
                if (!levelData) continue;
                
                const row = Math.floor((i - startLevel) / 5);
                const col = (i - startLevel) % 5;
                const isEvenRow = row % 2 === 0;
                
                const x = isEvenRow ? 
                    20 + (col * 60) : 
                    20 + ((4 - col) * 60);
                const y = 100 + (row * 80);
                
                pathPoints.push({ x: x + '%', y: y + 'px' });
                
                const node = createMapNode(levelData, x + '%', y + 'px');
                mapContainer.appendChild(node);
                nodes.push(node);
            }
            
            // Generar l√≠nea de conexi√≥n
            if (pathPoints.length > 1) {
                createPathLine(pathSvg, pathPoints);
            }
            
            // Actualizar navegaci√≥n
            updateMapNavigation(currentChapter);
        }

        function createMapNode(levelData, x, y) {
            const node = document.createElement('div');
            node.className = 'node';
            node.style.left = x;
            node.style.top = y;
            node.textContent = levelData.id;
            
            // Estados del nodo
            if (levelData.id > gameState.maxLevelUnlocked) {
                node.classList.add('locked');
            } else if (levelData.id === gameState.maxLevelUnlocked) {
                node.classList.add('current');
            } else {
                node.classList.add('completed');
            }
            
            // Boss
            if (levelData.tags.includes('boss')) {
                node.classList.add('boss');
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = 'BOSS';
                node.appendChild(label);
            }
            
            // Iconos de mec√°nicas
            if (levelData.tags.length > 0) {
                const icons = document.createElement('div');
                icons.className = 'icons';
                levelData.tags.slice(0, 3).forEach(tag => {
                    if (MECHANICS_ICONS[tag]) {
                        const icon = document.createElement('span');
                        icon.className = 'icon';
                        icon.textContent = MECHANICS_ICONS[tag];
                        icons.appendChild(icon);
                    }
                });
                if (levelData.tags.length > 3) {
                    const more = document.createElement('span');
                    more.textContent = `+${levelData.tags.length - 3}`;
                    more.style.fontSize = '8px';
                    icons.appendChild(more);
                }
                node.appendChild(icons);
            }
            
            // Evento click
            node.addEventListener('click', () => {
                if (levelData.id <= gameState.maxLevelUnlocked) {
                    startLevel(levelData.id);
                } else {
                    playSound('error');
                    showToast('üîí Nivel bloqueado');
                }
            });
            
            return node;
        }

        function createPathLine(svg, points) {
            if (points.length < 2) return;
            
            let pathData = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                pathData += ` L ${points[i].x} ${points[i].y}`;
            }
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'path-line');
            svg.appendChild(path);
        }

        function updateMapTheme() {
            const currentChapter = Math.ceil(gameState.currentLevel / 50);
            const themeNames = ['', 'Oc√©ano', 'Isla', 'Volc√°n', 'Cielo', 'Noche'];
            const themeName = themeNames[currentChapter] || 'Desconocido';
            
            document.getElementById('currentChapter').textContent = currentChapter;
            document.getElementById('chapterName').textContent = themeName;
            
            // Aplicar tema
            document.body.className = `theme-${Math.min(currentChapter, 5)}`;
        }

        function updateMapNavigation(currentChapter) {
            const prevBtn = document.getElementById('prevChapterBtn');
            const nextBtn = document.getElementById('nextChapterBtn');
            
            prevBtn.disabled = currentChapter <= 1;
            nextBtn.disabled = currentChapter >= Math.ceil(levelsData.length / 50);
        }

        function changeChapter(direction) {
            const currentChapter = Math.ceil(gameState.currentLevel / 50);
            const newChapter = currentChapter + direction;
            const maxChapters = Math.ceil(levelsData.length / 50);
            
            if (newChapter >= 1 && newChapter <= maxChapters) {
                gameState.currentLevel = (newChapter - 1) * 50 + 1;
                generateMap();
                updateMapTheme();
            }
        }

        // =====================================
        // RESTO DEL C√ìDIGO DEL JUEGO
        // (Mismo que la versi√≥n local pero con llamadas a API)
        // =====================================

        function startLevel(levelId) {
            if (gameState.lives <= 0) {
                showModal('noLivesModal');
                return;
            }
            
            const levelData = levelsData.find(l => l.id === levelId);
            if (!levelData) {
                console.error('‚ùå Nivel no encontrado:', levelId);
                return;
            }
            
            gameState.currentLevel = levelId;
            gameState.isPlaying = true;
            gameState.isPaused = false;
            
            // Inicializar datos del juego
            gameState.gameData = {
                pairs: levelData.pairs,
                timeLimit: levelData.time_sec,
                timeUsed: 0,
                movesUsed: 0,
                fails: 0,
                mechanics: [...levelData.tags],
                flippedCards: [],
                matchedCards: [],
                gameTimer: null,
                startTime: Date.now()
            };
            
            showScreen('gameScreen');
            setupGameUI(levelData);
            generateCards(levelData);
            startGameTimer();
            
            playSound('start');
            console.log(`üéÆ Iniciando nivel ${levelId}:`, levelData);
        }

        // [El resto de las funciones del juego son id√©nticas a la versi√≥n local]
        // Solo cambio las funciones que guardan datos para usar las APIs

        async function completeLevel() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameData.gameTimer);
            
            // Calcular puntuaci√≥n
            const coins = calculateCoins();
            const stars = calculateStars(coins);
            
            // Actualizar progreso local
            const oldCoins = gameState.coins;
            gameState.coins += coins;
            gameState.maxLevelUnlocked = Math.max(gameState.maxLevelUnlocked, gameState.currentLevel + 1);
            
            // Guardar en servidor si no es invitado
            if (!gameState.isGuest) {
                try {
                    await saveGameResult(true, coins);
                } catch (error) {
                    console.warn('Error guardando resultado:', error);
                }
            }
            
            // Guardar localmente
            saveUserData();
            updateUI();
            
            // Mostrar modal de victoria
            showVictoryModal(coins, stars);
            
            playSound('victory');
            createParticles('üéâ');
        }

        async function gameOver() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameData.gameTimer);
            
            // Restar vida
            gameState.lives = Math.max(0, gameState.lives - 1);
            
            // Guardar resultado en servidor si no es invitado
            if (!gameState.isGuest) {
                try {
                    await saveGameResult(false, 0);
                } catch (error) {
                    console.warn('Error guardando resultado:', error);
                }
            }
            
            saveUserData();
            updateUI();
            
            if (gameState.lives > 0) {
                showModal('defeatModal');
                document.getElementById('remainingLives').textContent = gameState.lives;
            } else {
                showModal('noLivesModal');
                startLifeTimer();
            }
            
            playSound('defeat');
        }

        async function saveGameResult(completed, coinsEarned) {
            if (gameState.isGuest) return; // No guardar si es invitado
            
            try {
                const response = await fetch(API_BASE + 'game.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'save_result',
                        user_key: gameState.currentUser,
                        level_id: gameState.currentLevel,
                        pairs: gameState.gameData.pairs,
                        time_seconds: gameState.gameData.timeUsed,
                        moves_used: gameState.gameData.movesUsed,
                        fails: gameState.gameData.fails,
                        coins_earned: coinsEarned,
                        completed: completed,
                        game_data: {
                            mechanics: gameState.gameData.mechanics,
                            chapter: Math.ceil(gameState.currentLevel / 50)
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.updated_data) {
                    // Actualizar datos locales con respuesta del servidor
                    gameState.maxLevelUnlocked = result.updated_data.max_level_unlocked;
                    gameState.coins = result.updated_data.coins_total;
                    gameState.lives = result.updated_data.lives_current;
                }
                
            } catch (error) {
                console.error('Error guardando resultado en servidor:', error);
                throw error;
            }
        }

        // [Incluir todas las dem√°s funciones del juego...]
        // Por brevedad, incluyo solo las funciones principales modificadas

        function setupGameUI(levelData) {
            document.getElementById('currentLevel').textContent = levelData.id;
            
            // Iconos de mec√°nicas
            const mechanicsContainer = document.getElementById('mechanicsIcons');
            mechanicsContainer.innerHTML = '';
            levelData.tags.forEach(tag => {
                if (MECHANICS_ICONS[tag]) {
                    const icon = document.createElement('span');
                    icon.textContent = MECHANICS_ICONS[tag];
                    icon.title = tag;
                    mechanicsContainer.appendChild(icon);
                }
            });
            
            // Barra de tiempo
            const timerBar = document.getElementById('timerBar');
            if (levelData.time_sec > 0) {
                timerBar.classList.remove('hidden');
                document.getElementById('timerFill').style.width = '100%';
            } else {
                timerBar.classList.add('hidden');
            }
            
            // Resetear contadores
            updateGameStats();
        }

        function generateCards(levelData) {
            const grid = document.getElementById('cardsGrid');
            grid.innerHTML = '';
            
            const totalCards = levelData.pairs * (levelData.tags.includes('triple') ? 3 : 2);
            const cardsPerRow = Math.ceil(Math.sqrt(totalCards));
            
            // Configurar grid
            grid.className = `cards-grid grid-${Math.min(cardsPerRow, 6)}`;
            
            // Generar cartas
            const cardTypes = generateCardTypes(levelData);
            const shuffledCards = shuffleArray(cardTypes);
            
            shuffledCards.forEach((cardType, index) => {
                const card = createCard(cardType, index);
                grid.appendChild(card);
            });
            
            // Aplicar efectos especiales
            applySpecialMechanics(levelData);
        }

        function generateCardTypes(levelData) {
            const cards = [];
            const isTriple = levelData.tags.includes('triple');
            const matchSize = isTriple ? 3 : 2;
            
            // Seleccionar emojis determin√≠sticamente
            const seed = 12345 + levelData.id; // Seed fijo para consistencia
            const rng = createSeededRandom(seed);
            const selectedEmojis = shuffleArrayWithRNG([...CARD_EMOJIS], rng).slice(0, levelData.pairs);
            
            // Crear cartas
            selectedEmojis.forEach(emoji => {
                for (let i = 0; i < matchSize; i++) {
                    cards.push({
                        type: emoji,
                        id: `${emoji}_${i}`,
                        matched: false,
                        flipped: false,
                        special: false
                    });
                }
            });
            
            return cards;
        }

        function createCard(cardData, index) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.index = index;
            card.dataset.type = cardData.type;
            card.dataset.id = cardData.id;
            
            // Contenido inicial (reverso)
            card.innerHTML = '<span class="back">‚ùì</span>';
            
            // Evento click
            card.addEventListener('click', () => handleCardClick(card, index));
            
            return card;
        }

        function handleCardClick(card, index) {
            if (gameState.isPaused || !gameState.isPlaying) return;
            if (card.classList.contains('flipped') || card.classList.contains('matched')) return;
            
            // Voltear carta
            flipCard(card);
            gameState.gameData.movesUsed++;
            gameState.gameData.flippedCards.push({ card, index });
            
            playSound('flip');
            updateGameStats();
            
            // Verificar parejas
            const flippedCards = gameState.gameData.flippedCards;
            const matchSize = gameState.gameData.mechanics.includes('triple') ? 3 : 2;
            
            if (flippedCards.length === matchSize) {
                setTimeout(() => checkMatch(flippedCards), 800);
            }
        }

        function flipCard(card) {
            card.classList.add('flipped', 'flip-animation');
            card.innerHTML = `<span class="front">${card.dataset.type}</span>`;
        }

        function checkMatch(flippedCards) {
            const types = flippedCards.map(fc => fc.card.dataset.type);
            const isMatch = types.every(type => type === types[0]);
            
            if (isMatch) {
                // ¬°Pareja encontrada!
                flippedCards.forEach(fc => {
                    fc.card.classList.add('matched');
                    fc.card.classList.remove('flipped');
                    gameState.gameData.matchedCards.push(fc);
                });
                
                playSound('match');
                createParticles('‚ú®', flippedCards[0].card);
                
                // Verificar victoria
                const totalPairs = gameState.gameData.pairs;
                const matchedPairs = gameState.gameData.matchedCards.length / 
                    (gameState.gameData.mechanics.includes('triple') ? 3 : 2);
                
                if (matchedPairs >= totalPairs) {
                    setTimeout(() => completeLevel(), 500);
                }
                
            } else {
                // Fallo
                gameState.gameData.fails++;
                flippedCards.forEach(fc => {
                    fc.card.classList.add('wrong');
                    setTimeout(() => {
                        fc.card.classList.remove('flipped', 'wrong', 'flip-animation');
                        fc.card.innerHTML = '<span class="back">‚ùì</span>';
                    }, 1000);
                });
                
                playSound('fail');
                updateGameStats();
            }
            
            // Limpiar cartas volteadas
            gameState.gameData.flippedCards = [];
        }

        function applySpecialMechanics(levelData) {
            // Implementar mec√°nicas especiales
            if (levelData.tags.includes('fantasma')) {
                showGhostCards();
            }
            
            if (levelData.tags.includes('niebla')) {
                applyFogEffect();
            }
            
            if (levelData.tags.includes('espejo')) {
                applyMirrorEffect();
            }
            
            // M√°s mec√°nicas...
        }

        function showGhostCards() {
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                card.classList.add('ghost');
                flipCard(card);
            });
            
            setTimeout(() => {
                cards.forEach(card => {
                    card.classList.remove('ghost', 'flipped', 'flip-animation');
                    card.innerHTML = '<span class="back">‚ùì</span>';
                });
            }, 2000);
        }

        function applyFogEffect() {
            setInterval(() => {
                if (!gameState.isPlaying) return;
                
                const cards = document.querySelectorAll('.card:not(.matched)');
                cards.forEach(card => {
                    if (Math.random() < 0.3) {
                        card.classList.toggle('fog');
                    }
                });
            }, 3000);
        }

        function applyMirrorEffect() {
            const grid = document.getElementById('cardsGrid');
            grid.style.transform = 'scaleX(-1)';
        }

        // =====================================
        // GESTI√ìN DEL TIEMPO Y ESTAD√çSTICAS
        // =====================================

        function startGameTimer() {
            if (gameState.gameData.gameTimer) {
                clearInterval(gameState.gameData.gameTimer);
            }
            
            gameState.gameData.gameTimer = setInterval(() => {
                if (gameState.isPaused || !gameState.isPlaying) return;
                
                gameState.gameData.timeUsed = Math.floor((Date.now() - gameState.gameData.startTime) / 1000);
                updateGameStats();
                
                // Verificar tiempo l√≠mite
                if (gameState.gameData.timeLimit > 0 && 
                    gameState.gameData.timeUsed >= gameState.gameData.timeLimit) {
                    gameOver();
                }
            }, 1000);
        }

        function updateGameStats() {
            const timeUsed = gameState.gameData.timeUsed;
            const minutes = Math.floor(timeUsed / 60);
            const seconds = timeUsed % 60;
            
            document.getElementById('timeDisplay').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('movesDisplay').textContent = gameState.gameData.movesUsed;
            document.getElementById('failsDisplay').textContent = gameState.gameData.fails;
            
            // Actualizar barra de tiempo
            if (gameState.gameData.timeLimit > 0) {
                const percentage = Math.max(0, 
                    (gameState.gameData.timeLimit - gameState.gameData.timeUsed) / gameState.gameData.timeLimit * 100
                );
                document.getElementById('timerFill').style.width = percentage + '%';
            }
        }

        function calculateCoins() {
            const data = gameState.gameData;
            const config = {
                TIME_MAX: 50,
                EFF_MAX: 50,
                PEN_FAIL: 2,
                PEN_BOMB: 4,
                MECH_MULTS: {
                    'triple': 0.10, 'camaleon': 0.05, 'barajar': 0.05,
                    'espejo': 0.05, 'bomba': 0.05, 'trampa': 0.05,
                    'niebla': 0.05, 'fantasma': 0.05, 'comodin': 0.05
                },
                MECH_MULT_CAP: 1.30
            };
            
            // Base por tama√±o
            const base = 100 * data.pairs;
            
            // Bonus de tiempo
            const timeTarget = getTimeTarget(data.pairs);
            const timeRatio = Math.min(timeTarget / Math.max(data.timeUsed, 1), 1.5);
            let timeBonus = Math.round(config.TIME_MAX * Math.min(timeRatio, 1.0));
            
            // Bonus extra por rapidez
            if (timeRatio > 1) {
                timeBonus += Math.min(Math.ceil((timeRatio - 1) * 10), 10);
            }
            
            // Bonus de eficiencia
            const isTriple = data.mechanics.includes('triple');
            const movesOpt = data.pairs * (isTriple ? 3 : 2);
            const effRatio = Math.min(movesOpt / Math.max(data.movesUsed, 1), 1);
            const effBonus = Math.round(config.EFF_MAX * effRatio);
            
            // Penalizaciones
            const penalties = config.PEN_FAIL * data.fails;
            
            // Multiplicadores
            let mult = 1.0;
            data.mechanics.forEach(mech => {
                if (config.MECH_MULTS[mech]) {
                    mult += config.MECH_MULTS[mech];
                }
            });
            mult = Math.min(mult, config.MECH_MULT_CAP);
            
            // C√°lculo final
            const coinsRaw = (base + timeBonus + effBonus - penalties) * mult;
            return Math.max(0, Math.round(coinsRaw));
        }

        function calculateStars(coins) {
            const pairs = gameState.gameData.pairs;
            let thresholds;
            
            if (pairs <= 5) {
                thresholds = { one: 80, two: 120, three: 160 };
            } else if (pairs <= 9) {
                thresholds = { one: 140, two: 190, three: 240 };
            } else {
                thresholds = { one: 200, two: 260, three: 320 };
            }
            
            if (coins >= thresholds.three) return 3;
            if (coins >= thresholds.two) return 2;
            if (coins >= thresholds.one) return 1;
            return 0;
        }

        function getTimeTarget(pairs) {
            if (pairs >= 10) return 100;
            if (pairs >= 8) return 80;
            if (pairs >= 6) return 65;
            return 50;
        }

        function showVictoryModal(coins, stars) {
            const modal = document.getElementById('victoryModal');
            const breakdown = document.getElementById('scoreBreakdown');
            
            document.getElementById('victoryLevel').textContent = gameState.currentLevel;
            
            // Crear desglose de puntuaci√≥n
            const data = gameState.gameData;
            const base = 100 * data.pairs;
            const timeBonus = Math.round(50 * Math.min(getTimeTarget(data.pairs) / Math.max(data.timeUsed, 1), 1));
            const effBonus = Math.round(50 * Math.min((data.pairs * 2) / Math.max(data.movesUsed, 1), 1));
            const penalties = 2 * data.fails;
            
            breakdown.innerHTML = `
                <div class="score-line">
                    <span>Base (${data.pairs} parejas):</span>
                    <span>+${base}</span>
                </div>
                <div class="score-line">
                    <span>Bonus tiempo:</span>
                    <span>+${timeBonus}</span>
                </div>
                <div class="score-line">
                    <span>Bonus eficiencia:</span>
                    <span>+${effBonus}</span>
                </div>
                <div class="score-line">
                    <span>Penalizaciones:</span>
                    <span>-${penalties}</span>
                </div>
                <div class="score-line score-total">
                    <span>Total:</span>
                    <span>${coins} ü™ô</span>
                </div>
                <div class="score-line">
                    <span>Estrellas:</span>
                    <span>${'‚≠ê'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)}</span>
                </div>
            `;
            
            showModal('victoryModal');
        }

        // =====================================
        // CONTROLES DEL JUEGO
        // =====================================

        function pauseGame() {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            gameState.isPaused = true;
            showModal('pauseModal');
        }

        function resumeGame() {
            gameState.isPaused = false;
            hideAllModals();
        }

        function retryLevel() {
            hideAllModals();
            startLevel(gameState.currentLevel);
        }

        function nextLevel() {
            hideAllModals();
            const nextLevelId = gameState.currentLevel + 1;
            if (nextLevelId <= levelsData.length && nextLevelId <= gameState.maxLevelUnlocked) {
                startLevel(nextLevelId);
            } else {
                backToMap();
            }
        }

        function backToMap() {
            gameState.isPlaying = false;
            gameState.isPaused = false;
            if (gameState.gameData.gameTimer) {
                clearInterval(gameState.gameData.gameTimer);
            }
            hideAllModals();
            showMap();
        }

        // =====================================
        // GESTI√ìN DE VIDAS
        // =====================================

        function startLifeTimer() {
            const updateTimer = () => {
                const now = Date.now();
                const lastRegen = localStorage.getItem('memoflip_last_life_regen_hostalia') || now;
                const timeSinceRegen = now - parseInt(lastRegen);
                const timeForNextLife = (60 * 60 * 1000) - (timeSinceRegen % (60 * 60 * 1000));
                
                if (timeSinceRegen >= 60 * 60 * 1000) {
                    // Regenerar vida
                    gameState.lives = Math.min(5, gameState.lives + 1);
                    localStorage.setItem('memoflip_last_life_regen_hostalia', now.toString());
                    saveUserData();
                    updateUI();
                    
                    if (gameState.lives > 0) {
                        hideAllModals();
                        return;
                    }
                }
                
                const minutes = Math.floor(timeForNextLife / (60 * 1000));
                const seconds = Math.floor((timeForNextLife % (60 * 1000)) / 1000);
                
                const timerElement = document.getElementById('nextLifeTimer');
                if (timerElement) {
                    timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                
                setTimeout(updateTimer, 1000);
            };
            
            updateTimer();
        }

        // =====================================
        // UI Y UTILIDADES
        // =====================================

        function updateUI() {
            document.getElementById('coinsDisplay').textContent = gameState.coins;
            document.getElementById('livesDisplay').textContent = gameState.lives;
            document.getElementById('soundToggle').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            saveUserData();
            updateUI();
            playSound('click');
        }

        function showModal(modalId) {
            hideAllModals();
            document.getElementById(modalId).classList.remove('hidden');
        }

        function hideAllModals() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.add('hidden');
            });
        }

        function showToast(message, duration = 3000) {
            // Crear toast temporal
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--panel);
                color: var(--ink);
                padding: 0.8rem 1.2rem;
                border-radius: 0.5rem;
                border: 1px solid var(--muted);
                z-index: 1000;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, duration);
        }

        function createParticles(emoji, targetElement = null) {
            const container = document.getElementById('particles');
            const rect = targetElement ? targetElement.getBoundingClientRect() : 
                { left: window.innerWidth / 2, top: window.innerHeight / 2 };
            
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = emoji;
                particle.style.left = (rect.left + Math.random() * 40 - 20) + 'px';
                particle.style.top = (rect.top + Math.random() * 40 - 20) + 'px';
                container.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 2000);
            }
        }

        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            // Aqu√≠ se implementar√≠an los sonidos reales
            // Por ahora solo console.log para debug
            console.log(`üîä Sonido: ${type}`);
        }

        // =====================================
        // UTILIDADES MATEM√ÅTICAS
        // =====================================

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createSeededRandom(seed) {
            let currentSeed = seed;
            return function() {
                currentSeed = (currentSeed * 9301 + 49297) % 233280;
                return currentSeed / 233280;
            };
        }

        function shuffleArrayWithRNG(array, rng) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // =====================================
        // EVENTOS GLOBALES
        // =====================================

        // Prevenir zoom en dispositivos m√≥viles
        document.addEventListener('touchmove', function(e) {
            if (e.scale !== 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // Pausar juego al cambiar de pesta√±a
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && gameState.isPlaying && !gameState.isPaused) {
                pauseGame();
            }
        });

        console.log('üéÆ MemoFlip para Hostalia cargado y listo!');
    </script>
</body>
</html>
