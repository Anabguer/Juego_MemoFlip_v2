<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>üéÆ MemoFlip v2 ‚Äî Juego de Memoria √âpico</title>
<link rel="manifest" href="../assets/manifest.json">
<style>
:root{--bg:#0b132b;--ink:#eef;--panel:#111a33;--accent:#ffd447;--ok:#2a9d8f;--muted:#2a355f;--veil:rgba(255,255,255,.15);
--path:#8da9c4;--node:#ffd447;--nodeb:#caa435;--hud:#16213e}

/* Temas por cap√≠tulo */
.theme-0{--bg:#0b132b;--panel:#111a33;--hud:#16213e;--path:#8da9c4;--node:#ffd447;--nodeb:#caa435;} /* Oc√©ano */
.theme-1{--bg:#1b2a17;--panel:#253422;--hud:#2b4127;--path:#a5c59a;--node:#f1d86a;--nodeb:#b7a34a;} /* Jungla/Isla */
.theme-2{--bg:#2b0b0b;--panel:#3a1414;--hud:#451919;--path:#d8a5a5;--node:#ff8f47;--nodeb:#c56b33;} /* Volc√°n */
.theme-3{--bg:#0b162b;--panel:#10203d;--hud:#12264a;--path:#9db7e6;--node:#70d6ff;--nodeb:#53a7c0;} /* Cielo */
.theme-4{--bg:#221b2b;--panel:#2e2436;--hud:#372d42;--path:#c3a9d6;--node:#da77f2;--nodeb:#a85dc0;} /* Noche */

*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:'Segoe UI',-apple-system,BlinkMacSystemFont,Arial,sans-serif}

/* Header global - responsive mejorado */
header{
  padding:.6rem 1rem;background:var(--panel);display:flex;justify-content:space-between;align-items:center;
  position:sticky;top:0;z-index:100;box-shadow:0 2px 8px rgba(0,0,0,.3);min-height:60px;
}

.logo{font-weight:900;font-size:clamp(1.1rem,4vw,1.4rem);color:var(--accent);white-space:nowrap;}
.header-right{display:flex;gap:clamp(.4rem,2vw,.8rem);align-items:center;flex-wrap:wrap;}
.coins,.lives{display:flex;align-items:center;gap:.3rem;font-weight:bold;font-size:clamp(.8rem,3vw,1rem);min-width:44px;min-height:44px;justify-content:center;}
.sound-btn{background:none;border:none;font-size:clamp(1rem,4vw,1.2rem);cursor:pointer;min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;}

/* Botones con tap targets >= 44px */
.btn{
  background:linear-gradient(145deg,#1c2541,#0f1a33);border:1px solid var(--muted);color:var(--ink);
  padding:.6rem 1rem;border-radius:.7rem;cursor:pointer;font-weight:600;transition:all .2s;
  text-decoration:none;display:inline-block;text-align:center;min-width:44px;min-height:44px;
  font-size:clamp(13px,3vw,16px);
}
.btn:hover{background:linear-gradient(145deg,#223355,#1a2644);transform:translateY(-1px);}
.btn:disabled{opacity:.5;cursor:not-allowed;}
.btn-primary{background:linear-gradient(145deg,var(--accent),#caa435);color:#222;}
.btn-primary:hover{background:linear-gradient(145deg,#ffdc3a,#b8932f);}

main{height:calc(100vh - 60px)}
.hidden{display:none !important}

/* Pantalla de inicio */
#startScreen{
  display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:2rem;
  background:radial-gradient(circle at center,var(--panel),var(--bg));
}
.start-logo{font-size:clamp(2rem,8vw,3rem);font-weight:900;color:var(--accent);margin-bottom:.5rem;text-shadow:0 4px 8px rgba(0,0,0,.5);}
.start-subtitle{font-size:clamp(1rem,4vw,1.2rem);margin-bottom:3rem;opacity:.8;}
.start-buttons{display:flex;flex-direction:column;gap:1rem;min-width:250px;max-width:90vw;}

/* Mapa - basado en el ejemplo funcional */
#mapWrap{
  position:relative;height:100%;overflow:auto;
  background:radial-gradient(120% 80% at 50% 20%,#13315c,var(--bg));
  transition:transform .25s ease;
}
#map{position:relative;width:100%;height:180vh;min-height:840px;padding:2rem 0;}

.node{
  position:absolute;transform:translate(-50%,-50%);width:54px;height:54px;border-radius:50%;
  display:grid;place-items:center;font-weight:bold;background:var(--node);color:#222;
  border:2px solid var(--nodeb);box-shadow:0 6px 0 var(--nodeb);cursor:pointer;
  transition:all .2s;min-width:44px;min-height:44px;font-size:clamp(12px,3vw,14px);
}
.node:hover{transform:translate(-50%,-50%) scale(1.1);}
.node.lock{filter:grayscale(.85);opacity:.6;box-shadow:none;cursor:not-allowed;}
.node.current{outline:4px solid #5bc0be;outline-offset:2px;animation:pulse 2s infinite;}
.node.completed{background:var(--ok);border-color:#228b7a;}

.node .icons{
  position:absolute;bottom:-12px;left:50%;transform:translateX(-50%);
  font-size:10px;white-space:nowrap;display:flex;gap:1px;
}
.icon{margin:0 1px;}

.node.boss{
  width:68px;height:68px;
  background:linear-gradient(180deg,var(--node),#fff2b5);
  box-shadow:0 10px 0 var(--nodeb),0 0 24px rgba(255,212,71,.5);
}
.node.boss::after{content:"üëë";position:absolute;top:-18px;font-size:18px;}
.node.boss .label{
  position:absolute;bottom:-26px;left:50%;transform:translateX(-50%);
  font-size:11px;letter-spacing:.6px;opacity:.9;
}

#poly{position:absolute;inset:0;}

/* HUD del juego */
.hud{
  position:sticky;top:0;padding:.8rem 1rem;background:var(--hud);
  display:flex;justify-content:space-between;align-items:center;gap:.8rem;flex-wrap:wrap;z-index:50;
  box-shadow:0 2px 8px rgba(0,0,0,.3);min-height:60px;
}
.hudTitle{font-weight:900;font-size:clamp(16px,4vw,22px);}
.badges{display:flex;gap:.35rem;flex-wrap:wrap;margin-top:.2rem;}
.badge{
  background:#12233f;border:1px solid #2a355f;border-radius:.5rem;
  padding:.15rem .4rem;font-size:clamp(11px,2.5vw,12px);
  display:inline-flex;gap:.25rem;align-items:center;
}
.timer{font-weight:800;font-size:clamp(14px,4vw,18px);}

/* Barra de tiempo */
#barWrap{
  position:relative;height:8px;background:#0f1a33;border:1px solid #223355;
  border-radius:6px;overflow:hidden;width:46%;min-width:200px;
}
#bar{position:absolute;top:0;left:0;height:100%;background:var(--accent);transition:width .1s linear;}

/* Grid de cartas */
.grid{display:grid;gap:clamp(.3rem,1vw,.5rem);max-width:720px;margin:1rem auto;padding:0 1rem;}
.card{
  aspect-ratio:3/4;background:linear-gradient(145deg,#243b55,#1a2d44);
  border:2px solid #3b5b8a;border-radius:.8rem;display:grid;place-items:center;
  font-size:clamp(1.2rem,4vw,2rem);color:#fff;cursor:pointer;position:relative;overflow:hidden;
  transition:all .3s ease;user-select:none;min-width:44px;min-height:59px;
}
.card:hover{transform:scale(1.05);}
.card.flip{background:linear-gradient(145deg,#fff,#f0f0f0);color:#333;border-color:var(--accent);}
.card.matched{background:var(--ok);border-color:var(--ok);}
.card.wrong{background:linear-gradient(145deg,#e63946,#cc2936);animation:shake .5s;}

/* Efectos especiales */
.card.fog{opacity:.3;transition:opacity .3s;}
.card.ghost{opacity:.7;animation:ghostly 1s ease-in-out infinite alternate;}
.card.trap{filter:grayscale(1);pointer-events:none;}

/* Modales */
.modal{
  position:fixed;inset:0;display:grid;place-items:center;
  background:rgba(0,0,0,.7);z-index:200;backdrop-filter:blur(4px);
}
.modal.hidden{display:none !important;}
.modal .box{
  background:linear-gradient(145deg,var(--panel),var(--bg));border:2px solid var(--muted);
  border-radius:1rem;padding:2rem;min-width:300px;max-width:90vw;text-align:center;
  box-shadow:0 20px 40px rgba(0,0,0,.5);
}

.modal-title{font-size:clamp(1.2rem,5vw,1.5rem);font-weight:900;margin-bottom:1rem;color:var(--accent);}
.modal-content{margin-bottom:2rem;line-height:1.5;font-size:clamp(13px,3vw,16px);}
.modal-buttons{display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;}

.score-breakdown{
  background:rgba(0,0,0,.2);border-radius:.5rem;padding:1rem;margin:1rem 0;
  text-align:left;font-size:clamp(12px,3vw,14px);
}
.score-line{display:flex;justify-content:space-between;margin:.3rem 0;}
.score-total{border-top:1px solid var(--muted);padding-top:.5rem;font-weight:bold;color:var(--accent);}

/* Navegaci√≥n de cap√≠tulos */
#chapNav{
  display:flex;gap:.5rem;align-items:center;justify-content:center;
  padding:.6rem 1rem;background:var(--panel);border-top:1px solid #223355;
}
.chip{
  display:inline-flex;gap:.35rem;align-items:center;background:#0f1a33;
  border:1px solid #223355;border-radius:.5rem;padding:.3rem .6rem;
  font-size:clamp(11px,2.5vw,12px);
}

/* Efectos y animaciones */
#veil{
  position:fixed;left:0;right:0;top:60px;bottom:0;
  background:rgba(255,255,255,.15);backdrop-filter:blur(2px);
  opacity:0;pointer-events:none;z-index:150;transition:opacity .25s;
}
#veil.show{opacity:1;}

.fadeUp{transform:translateY(16px);opacity:0;animation:enterUp .28s ease forwards;}
@keyframes enterUp{to{transform:translateY(0);opacity:1;}}

@keyframes blink{0%{filter:brightness(1)} 50%{filter:brightness(1.35)} 100%{filter:brightness(1)}}
.camaleon{animation:blink .35s linear;}

.lockturn{pointer-events:none;opacity:.75;}

@keyframes pulse{0%,100%{transform:translate(-50%,-50%) scale(1);} 50%{transform:translate(-50%,-50%) scale(1.1);}}
@keyframes shake{0%,100%{transform:translateX(0);} 25%{transform:translateX(-5px);} 75%{transform:translateX(5px);}}
@keyframes ghostly{from{opacity:.3;} to{opacity:.8;}}

/* Responsive espec√≠fico */
@media (max-width: 480px) {
  header{padding:.4rem .6rem;}
  .header-right{gap:.2rem;}
  .hud{padding:.6rem .8rem;flex-direction:column;gap:.5rem;align-items:stretch;}
  .cards-grid{gap:.2rem;}
  .card{min-width:40px;min-height:53px;font-size:1.2rem;}
  .modal .box{padding:1.5rem;margin:1rem;}
  .modal-buttons{flex-direction:column;gap:.8rem;}
}

@media (max-width: 320px) {
  .grid{grid-template-columns:repeat(2,1fr) !important;}
}

/* Grid responsivo */
.grid-2{grid-template-columns:repeat(2,1fr);}
.grid-3{grid-template-columns:repeat(3,1fr);}
.grid-4{grid-template-columns:repeat(4,1fr);}
.grid-5{grid-template-columns:repeat(5,1fr);}
.grid-6{grid-template-columns:repeat(6,1fr);}

@media (max-width: 480px) {
  .grid-5,.grid-6{grid-template-columns:repeat(4,1fr);}
  .grid-4{grid-template-columns:repeat(3,1fr);}
}
</style>
</head>
<body class="theme-0">

<!-- Header global -->
<header>
  <div class="logo">üéÆ MemoFlip v2</div>
  <div class="header-right">
    <div class="coins">
      <span>ü™ô</span>
      <span id="coinsDisplay">0</span>
    </div>
    <div class="lives">
      <span>‚ù§Ô∏è</span>
      <span id="livesDisplay">5</span>
    </div>
    <button class="sound-btn" id="soundToggle" title="Sonido">üîä</button>
  </div>
</header>

<main>
  <!-- Pantalla de inicio -->
  <section id="StartView">
    <div id="startScreen">
      <div class="start-logo">üéÆ MemoFlip v2</div>
      <div class="start-subtitle">Juego de Memoria √âpico</div>
      <div class="start-buttons">
        <button class="btn btn-primary" id="btnStartGuest">üöÄ Jugar como Invitado</button>
        <button class="btn" id="btnLogin">üë§ Iniciar Sesi√≥n</button>
        <button class="btn" id="btnRegister">üìù Registrarse</button>
        <button class="btn" id="btnShowMap">üó∫Ô∏è Ver Mapa</button>
      </div>
    </div>
  </section>

  <!-- Vista del mapa -->
  <section id="MapView" class="hidden">
    <div id="mapWrap">
      <svg id="poly" preserveAspectRatio="none"></svg>
      <div id="map"></div>
    </div>
    <div id="chapNav">
      <button class="btn" id="btnDown">‚¨áÔ∏è Bajar tramo</button>
      <span class="chip" id="chipInfo">Tramo 1 ¬∑ Niveles 1‚Äì50</span>
      <button class="btn" id="btnUp">‚¨ÜÔ∏è Subir tramo</button>
    </div>
  </section>

  <!-- Vista del juego -->
  <section id="GameView" class="hidden">
    <div class="hud">
      <div>
        <div id="hudLevel" class="hudTitle">Nivel</div>
        <div id="hudBadges" class="badges"></div>
      </div>
      <div style="display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;">
        <div id="barWrap" class="hidden">
          <div id="bar" style="width:100%"></div>
        </div>
        <div id="hudTimer" class="timer"></div>
        <div class="game-stats" style="display:flex;gap:.5rem;font-size:clamp(11px,2.5vw,12px);">
          <div class="stat">üëÜ <span id="movesDisplay">0</span></div>
          <div class="stat">‚ùå <span id="failsDisplay">0</span></div>
        </div>
        <button class="btn" id="btnPause" title="Pausar">‚è∏Ô∏è</button>
      </div>
    </div>
    <div id="grid" class="grid"></div>
  </section>

  <!-- Modal de victoria -->
  <div id="win" class="modal hidden" aria-hidden="true">
    <div class="box">
      <div class="modal-title">üéâ ¬°Nivel completado!</div>
      <div class="modal-content">
        <p>¬°Has completado el nivel <span id="victoryLevel">1</span>!</p>
        <div class="score-breakdown" id="scoreBreakdown">
          <!-- Se llena din√°micamente -->
        </div>
      </div>
      <div class="modal-buttons">
        <button type="button" class="btn btn-primary" id="btnNextLevel">‚û°Ô∏è Siguiente</button>
        <button type="button" class="btn" id="btnRetryWin">üîÑ Reintentar</button>
        <button type="button" class="btn" id="btnMapWin">üó∫Ô∏è Mapa</button>
      </div>
    </div>
  </div>

  <!-- Modal de derrota -->
  <div id="fail" class="modal hidden" aria-hidden="true">
    <div class="box">
      <div class="modal-title">üíî Game Over</div>
      <div class="modal-content">
        <p id="failMessage">Tiempo agotado</p>
        <p>Te quedan <span id="remainingLives">4</span> vidas.</p>
      </div>
      <div class="modal-buttons">
        <button type="button" class="btn btn-primary" id="btnRetry">üîÑ Reintentar</button>
        <button type="button" class="btn" id="btnMapFail">üó∫Ô∏è Mapa</button>
      </div>
    </div>
  </div>

  <!-- Modal de sin vidas -->
  <div id="noLives" class="modal hidden" aria-hidden="true">
    <div class="box">
      <div class="modal-title">‚è∞ Sin Vidas</div>
      <div class="modal-content">
        <p>Te has quedado sin vidas.</p>
        <p>Regenerar√°s 1 vida cada hora.</p>
        <p>Pr√≥xima vida en: <span id="nextLifeTimer">59:59</span></p>
      </div>
      <div class="modal-buttons">
        <button type="button" class="btn btn-primary" id="btnMapNoLives">üó∫Ô∏è Volver al Mapa</button>
      </div>
    </div>
  </div>

  <!-- Modal de pausa -->
  <div id="pause" class="modal hidden" aria-hidden="true">
    <div class="box">
      <div class="modal-title">‚è∏Ô∏è Pausa</div>
      <div class="modal-content">
        <p>Juego pausado</p>
      </div>
      <div class="modal-buttons">
        <button type="button" class="btn btn-primary" id="btnResume">‚ñ∂Ô∏è Continuar</button>
        <button type="button" class="btn" id="btnRetryPause">üîÑ Reiniciar</button>
        <button type="button" class="btn" id="btnMapPause">üó∫Ô∏è Mapa</button>
      </div>
    </div>
  </div>
</main>

<!-- Velo para efectos -->
<div id="veil"></div>

<script>
document.addEventListener('DOMContentLoaded', function(){
  // =====================================
  // CONFIGURACI√ìN SEG√öN ESPECIFICACIONES
  // =====================================
  
  const CHAPTER_SIZE = 50;
  const TOTAL_LEVELS = 1000;
  const GLOBAL_SEED = 12345;
  
  // Configuraci√≥n de puntuaci√≥n seg√∫n memoflip_scoring_spec.md
  const SCORE_CONFIG = {
    TIME_MAX: 50,
    EFF_MAX: 50,
    PEN_FAIL: 2,
    PEN_BOMBA: 4,
    MECH_MULTS: { 
      triple: 0.10, camaleon: 0.05, barajar: 0.05, espejo: 0.05, 
      bomba: 0.05, trampa: 0.05, niebla: 0.05, fantasma: 0.05, comodin: 0.05 
    },
    MECH_MULT_CAP: 1.30,
    TARGETS: [
      { minPairs: 10, t: 100 },
      { minPairs: 8, t: 80 },
      { minPairs: 6, t: 65 },
      { minPairs: 0, t: 50 }
    ],
    STAR_THRESHOLDS: {
      small: { one: 80, two: 120, three: 160 },
      medium: { one: 140, two: 190, three: 240 },
      large: { one: 200, two: 260, three: 320 }
    }
  };
  
  const EMO = {
    crono:'‚è±Ô∏è', niebla:'üå´Ô∏è', barajar:'üîÄ', triple:'üî∫', camaleon:'üé≠', 
    trampa:'üö´', bomba:'üí£', comodin:'üåü', fantasma:'üëª', espejo:'ü™û', boss:'üëë'
  };
  
  const THEMES = ['theme-0','theme-1','theme-2','theme-3','theme-4'];
  
  // Iconos de cartas deterministas
  const ICONS = [
    'üê†','üêü','üê°','ü¶à','üêô','ü¶ë','üêö','‚≠ê','üåä','üèùÔ∏è',
    'ü¶Ä','ü¶û','üê¢','üê≥','üêã','ü¶≠','üêß','ü¶Ü','‚öì','üõ•Ô∏è',
    'üèñÔ∏è','üå∫','ü••','üçç','üå¥','ü¶©','ü¶ú','üêÖ','ü¶Å','üêò',
    'ü¶í','ü¶ì','ü¶è','üêä','üêç','ü¶é'
  ];

  // =====================================
  // ESTADO DEL JUEGO
  // =====================================
  
  let gameState = {
    currentUser: null,
    currentLevel: 1,
    maxLevelUnlocked: 1,
    coins: 0,
    lives: 5,
    soundEnabled: true,
    currentChapter: 0,
    levelRecords: {} // level_id: { bestCoins, bestTime, bestMoves, stars }
  };
  
  let currentChapter = 0;
  let unlocked = 1; // Nivel m√°ximo desbloqueado
  let LV = []; // Array de niveles
  
  // Estado del juego actual
  let state = {
    lvl: null,
    firsts: [],
    matches: 0,
    timeLeft: 0,
    raf: null,
    start: 0,
    iconsPool: null,
    gridEl: null,
    turnLocked: false,
    espejoTimer: null,
    engine: null,
    movesUsed: 0,
    fails: 0,
    bombasActivadas: 0
  };

  // =====================================
  // MOTOR DEL JUEGO (BASADO EN EJEMPLO)
  // =====================================
  
  const Engine = {
    matchSize: 2,
    time: 0,
    tags: [],
    hooks: { onStart: [], onFlip: [], onMatch: [], onMismatch: [], onTick: [] },
    
    use(plugin) {
      if (!plugin) return;
      if (plugin.onStart) this.hooks.onStart.push(plugin.onStart);
      if (plugin.onFlip) this.hooks.onFlip.push(plugin.onFlip);
      if (plugin.onMatch) this.hooks.onMatch.push(plugin.onMatch);
      if (plugin.onMismatch) this.hooks.onMismatch.push(plugin.onMismatch);
      if (plugin.onTick) this.hooks.onTick.push(plugin.onTick);
    },
    
    reset() {
      this.matchSize = 2;
      this.time = 0;
      this.tags = [];
      this.hooks = { onStart: [], onFlip: [], onMatch: [], onMismatch: [], onTick: [] };
    }
  };

  // =====================================
  // PLUGINS DE MEC√ÅNICAS (TODAS IMPLEMENTADAS)
  // =====================================
  
  const Plugins = {
    crono: {
      name: 'crono',
      onStart(ctx) {
        if (ctx.lvl.t > 0) {
          show($('barWrap'));
          $('bar').style.width = '100%';
        } else {
          hide($('barWrap'));
        }
      },
      onTick(ctx, now, elapsed, rem) {
        if (ctx.lvl.t > 0) {
          $('hudTimer').textContent = fmt(rem);
          $('bar').style.width = (Math.max(0, Math.min(1, rem / ctx.lvl.t)) * 100).toFixed(1) + '%';
          if (rem <= 0) ctx.fail();
        }
      }
    },
    
    niebla: {
      name: 'niebla',
      onMismatch(ctx) {
        const v = $('veil');
        v.classList.add('show');
        setTimeout(() => v.classList.remove('show'), 280);
      }
    },
    
    barajar: {
      name: 'barajar',
      onTick(ctx, now, elapsed, rem) {
        if (ctx.lvl.t > 0 && !ctx._shuffled && rem <= Math.floor(ctx.lvl.t / 2)) {
          ctx._shuffled = true;
          reshuffleSome(ctx.gridEl, 6);
          showToast('üîÄ ¬°Cartas barajadas!');
        }
      }
    },
    
    triple: {
      name: 'triple',
      onStart(ctx) {
        ctx.engine.matchSize = 3;
      }
    },
    
    camaleon: {
      name: 'camaleon',
      onTick(ctx, now, elapsed, rem) {
        if (!ctx._lastCam) ctx._lastCam = 0;
        if (elapsed - ctx._lastCam >= 4) {
          ctx._lastCam = elapsed;
          const icons = ctx.iconsPool;
          const cells = [...ctx.gridEl.children];
          
          cells.forEach(c => {
            if (c.classList.contains('matched')) return;
            const id = parseInt(c.getAttribute('data-id'), 10);
            c.classList.add('camaleon');
            c.dataset.iconOverride = icons[(id + Math.floor(Math.random() * icons.length)) % icons.length];
            if (c.classList.contains('flip')) {
              c.textContent = c.dataset.iconOverride;
            }
            setTimeout(() => c.classList.remove('camaleon'), 320);
          });
        }
      }
    },
    
    trampa: {
      name: 'trampa',
      onFlip(ctx, card) {
        const idx = parseInt(card.getAttribute('data-idx'), 10);
        if (idx % 8 === 0 && !card.classList.contains('matched')) {
          ctx.turnLocked = true;
          document.body.classList.add('lockturn');
          showToast('üö´ Carta trampa activada');
          setTimeout(() => {
            ctx.turnLocked = false;
            document.body.classList.remove('lockturn');
          }, 680);
        }
      }
    },
    
    bomba: {
      name: 'bomba',
      onMismatch(ctx) {
        if (ctx.lvl.t > 0) {
          ctx._pen = (ctx._pen || 0) + 4;
          ctx.timeLeft = Math.max(0, ctx.timeLeft - 4);
          state.bombasActivadas++;
          showToast('üí£ ¬°Bomba! -4 segundos');
          createParticles('üí•');
        }
      }
    },
    
    comodin: {
      name: 'comodin',
      onStart(ctx) {
        const cards = [...ctx.gridEl.children];
        for (let i = 0; i < cards.length && i < 2; i++) {
          cards[i].dataset.isWild = '1';
          cards[i].classList.add('special');
        }
      }
    },
    
    fantasma: {
      name: 'fantasma',
      onStart(ctx) {
        const cells = [...ctx.gridEl.children];
        cells.forEach(c => {
          c.classList.add('ghost');
          flipUp(c, ctx);
        });
        setTimeout(() => {
          cells.forEach(c => {
            if (!c.classList.contains('matched')) {
              flipDown(c);
              c.classList.remove('ghost');
            }
          });
        }, 2000);
      }
    },
    
    espejo: {
      name: 'espejo',
      onStart(ctx) {
        const cells = [...ctx.gridEl.children];
        cells.forEach(c => flipUp(c, ctx));
        let steps = 0;
        ctx.espejoTimer = setInterval(() => {
          shuffleIcons(ctx);
          steps++;
          if (steps >= 6) {
            clearInterval(ctx.espejoTimer);
            ctx.espejoTimer = null;
            cells.forEach(c => {
              if (!c.classList.contains('matched')) {
                flipDown(c);
              }
            });
          }
        }, 820);
      }
    }
  };

  // =====================================
  // GENERACI√ìN DE NIVELES (MEJORADA)
  // =====================================
  
  function buildLevels(N, seed) {
    let LV = [];
    let rng = RNG(seed);
    let lastTimed = 0;
    let lastBigRun = 0;
    
    // Plan espec√≠fico para los primeros 20 niveles (tutorial)
    const plan20 = [
      [2, 0, []], [3, 0, []], [2, 0, []], [4, 0, []],
      [6, 80, ['crono']], [4, 0, ['niebla']], [6, 0, []], [5, 75, ['crono', 'barajar']],
      [4, 0, []], [10, 95, ['crono']], [3, 0, []], [5, 0, ['camaleon']],
      [4, 0, []], [8, 0, []], [6, 78, ['crono']], [4, 0, ['fantasma']],
      [12, 0, []], [5, 0, []], [6, 72, ['crono']], [8, 76, ['crono']]
    ];
    
    // Primeros 20 niveles con plan espec√≠fico
    for (let i = 1; i <= Math.min(20, N); i++) {
      let [pairs, t, tags] = plan20[i - 1];
      const matchSize = tags.includes('triple') ? 3 : 2;
      LV.push({
        id: i,
        pairs: pairs,
        matchSize: matchSize,
        t: t,
        time_sec: t,
        tags: tags.slice(),
        chapter: Math.ceil(i / 50),
        seed: seed + i,
        label: t > 0 ? 'medio' : 'f√°cil',
        note: ''
      });
      if (t > 0) lastTimed++;
      else lastTimed = 0;
    }
    
    // Resto de niveles con generaci√≥n procedural
    for (let i = 21; i <= N; i++) {
      let base = Math.min(12, 2 + Math.floor((i - 1) / 8));
      let mod = ((i % 20 === 0) ? -2 : (i % 10 === 0) ? +2 : 0);
      let pairs = Math.max(2, Math.min(12, base + mod));
      
      if (i % 6 === 0) pairs = Math.min(pairs, 4);
      if ((i % 13 === 0) || (i % 14 === 0 && rng() < 0.4)) {
        pairs = Math.min(12, Math.max(pairs, 10));
      }
      
      if (pairs === 12) {
        lastBigRun++;
        if (lastBigRun > 2) {
          pairs = 10;
          lastBigRun = 0;
        }
      } else if (pairs >= 10) {
        // OK
      } else {
        lastBigRun = 0;
      }
      
      let t = 0;
      if (pairs >= 10) t = 92 + Math.floor(rng() * 14);
      else if (pairs >= 8) t = 70 + Math.floor(rng() * 12);
      else if (pairs >= 6) t = 60 + Math.floor(rng() * 10);
      else t = 0;
      
      if (t > 0) {
        if (lastTimed >= 2) {
          t = 0;
        } else {
          lastTimed++;
        }
      } else {
        lastTimed = 0;
      }
      
      let tags = [];
      let note = '';
      let label = 'medio';
      
      // Bosses cada 50 niveles
      if (i % 50 === 0) {
        const variant = Math.floor(i / 50) % 4;
        pairs = 12;
        t = 110;
        label = 'boss';
        
        if (variant === 1) {
          tags = ['boss', 'crono', 'barajar', 'camaleon', 'bomba'];
          note = 'üëë Jefe: Tormenta cambiante';
        } else if (variant === 2) {
          tags = ['boss', 'crono', 'triple', 'trampa'];
          t = 125;
          pairs = 10;
          note = 'üëë Jefe: Triada t√°ctica';
        } else if (variant === 3) {
          tags = ['boss', 'crono', 'fantasma', 'espejo'];
          t = 115;
          pairs = 10;
          note = 'üëë Jefe: Memoria viva';
        } else {
          tags = ['boss', 'crono', 'camaleon', 'trampa', 'bomba'];
          note = 'üëë Jefe: Marea roja';
        }
        lastTimed = 1;
      } else {
        // Mec√°nicas por rangos de niveles
        if (i <= 100) {
          if (i % 5 === 0) tags.push('crono');
          if (i % 7 === 0) tags.push('barajar');
          if (i % 9 === 0) tags.push('camaleon');
          if (i % 11 === 0) tags.push('niebla');
          if (i % 16 === 0) tags.push('triple');
        } else if (i <= 300) {
          if (i % 5 === 0) tags.push('triple');
          if (i % 9 === 0) tags.push('camaleon');
          if (i % 12 === 0) tags.push('bomba');
          if (i % 15 === 0) tags.push('fantasma');
          if (i % 18 === 0) tags.push('trampa');
        } else if (i <= 600) {
          if (i % 4 === 0) tags.push('crono');
          if (i % 8 === 0) tags.push('trampa');
          if (i % 10 === 0) tags.push('comodin');
          if (i % 13 === 0) tags.push('espejo');
        } else {
          if (i % 3 === 0) tags.push('crono');
          if (i % 7 === 0) tags.push('bomba');
          if (i % 11 === 0) tags.push('espejo');
          if (i % 13 === 0) tags.push('comodin');
        }
        
        // Picos y respiros
        if (i % 30 === 0) {
          note = 'üî• pico';
          t = Math.max(t, 95);
          pairs = Math.max(pairs, 10);
          label = 'dif√≠cil';
        }
        if (i % 30 === 1) {
          note = 'üí§ respiro';
          t = 0;
          pairs = Math.min(pairs, 4);
          label = 'f√°cil';
        }
      }
      
      const matchSize = tags.includes('triple') ? 3 : 2;
      
      LV.push({
        id: i,
        pairs: pairs,
        matchSize: matchSize,
        t: t,
        time_sec: t,
        tags: tags,
        chapter: Math.ceil(i / 50),
        seed: seed + i,
        label: label,
        note: note
      });
    }
    
    return LV;
  }

  // =====================================
  // UTILIDADES
  // =====================================
  
  function RNG(seed) {
    let s = seed >>> 0;
    return function() {
      s = (s * 1664525 + 1013904223) >>> 0;
      return s / 4294967296;
    };
  }
  
  function $(id) { return document.getElementById(id); }
  function show(el) { el.classList.remove('hidden'); el.setAttribute('aria-hidden', 'false'); }
  function hide(el) { el.classList.add('hidden'); el.setAttribute('aria-hidden', 'true'); }
  
  function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const t = a[i];
      a[i] = a[j];
      a[j] = t;
    }
    return a;
  }
  
  function fmt(s) {
    const m = String(Math.floor(s / 60)).padStart(2, '0');
    const r = String(s % 60).padStart(2, '0');
    return m + ':' + r;
  }

  // =====================================
  // GESTI√ìN DE DATOS DE USUARIO
  // =====================================
  
  function loadUserData() {
    const savedData = localStorage.getItem('memoflip_v2_user');
    if (savedData) {
      try {
        const userData = JSON.parse(savedData);
        gameState.currentUser = userData.userId || 'guest_' + Date.now();
        gameState.maxLevelUnlocked = userData.maxLevel || 1;
        gameState.coins = userData.coins || 0;
        gameState.lives = userData.lives || 5;
        gameState.soundEnabled = userData.soundEnabled !== false;
        gameState.levelRecords = userData.levelRecords || {};
        
        unlocked = gameState.maxLevelUnlocked;
        
        // Regenerar vidas
        regenerateLives();
        
      } catch (e) {
        console.warn('Error cargando datos:', e);
        resetUserData();
      }
    } else {
      resetUserData();
    }
  }
  
  function resetUserData() {
    gameState.currentUser = 'guest_' + Date.now();
    gameState.maxLevelUnlocked = 1;
    gameState.coins = 0;
    gameState.lives = 5;
    gameState.soundEnabled = true;
    gameState.levelRecords = {};
    unlocked = 1;
  }
  
  function saveUserData() {
    const userData = {
      userId: gameState.currentUser,
      maxLevel: gameState.maxLevelUnlocked,
      coins: gameState.coins,
      lives: gameState.lives,
      soundEnabled: gameState.soundEnabled,
      levelRecords: gameState.levelRecords,
      lastSave: Date.now(),
      lastLifeRegen: localStorage.getItem('memoflip_last_life_regen') || Date.now()
    };
    localStorage.setItem('memoflip_v2_user', JSON.stringify(userData));
  }
  
  function regenerateLives() {
    const now = Date.now();
    const lastRegen = parseInt(localStorage.getItem('memoflip_last_life_regen') || now);
    const hoursPassed = Math.floor((now - lastRegen) / (60 * 60 * 1000));
    
    if (hoursPassed > 0 && gameState.lives < 5) {
      gameState.lives = Math.min(5, gameState.lives + hoursPassed);
      localStorage.setItem('memoflip_last_life_regen', now.toString());
      console.log(`‚ù§Ô∏è Regeneradas ${hoursPassed} vidas. Total: ${gameState.lives}`);
    }
  }

  // =====================================
  // SISTEMA DE PUNTUACI√ìN (SEG√öN SPEC)
  // =====================================
  
  function calculateCoins(levelData, timeUsed, movesUsed, fails, bombasActivadas) {
    const pairs = levelData.pairs;
    const mechanics = levelData.tags;
    const config = SCORE_CONFIG;
    
    // BASE = 100 * pairs
    const base = 100 * pairs;
    
    // Tiempo objetivo
    const timeTarget = getTimeTarget(pairs);
    
    // TIME_BONUS: lleno si time_used <= t_target
    const timeRatio = Math.min(timeTarget / Math.max(timeUsed, 1), 1.5);
    let timeBonus = Math.round(config.TIME_MAX * Math.min(timeRatio, 1.0));
    
    // Bonus extra por rapidez
    if (timeRatio > 1) {
      timeBonus += Math.min(Math.ceil((timeRatio - 1) * 10), 10);
    }
    
    // EFF_BONUS: proporcional a (moves_opt / moves_used)
    const movesOpt = pairs * levelData.matchSize;
    const effRatio = Math.min(movesOpt / Math.max(movesUsed, 1), 1);
    const effBonus = Math.round(config.EFF_MAX * effRatio);
    
    // Penalizaciones: fails y bombas
    const penalties = (config.PEN_FAIL * fails) + (config.PEN_BOMBA * bombasActivadas);
    
    // Multiplicadores por mec√°nicas (cap 1.30)
    let mult = 1.0;
    mechanics.forEach(mech => {
      if (config.MECH_MULTS[mech]) {
        mult += config.MECH_MULTS[mech];
      }
    });
    mult = Math.min(mult, config.MECH_MULT_CAP);
    
    // C√°lculo final
    const coinsRaw = (base + timeBonus + effBonus - penalties) * mult;
    const coins = Math.max(0, Math.round(coinsRaw));
    
    return {
      coins,
      breakdown: {
        base,
        timeBonus,
        effBonus,
        penalties,
        mult: Math.round(mult * 100) / 100
      }
    };
  }
  
  function getTimeTarget(pairs) {
    for (const target of SCORE_CONFIG.TARGETS) {
      if (pairs >= target.minPairs) {
        return target.t;
      }
    }
    return 50;
  }
  
  function calculateStars(coins, pairs) {
    const thresholds = pairs <= 5 ? SCORE_CONFIG.STAR_THRESHOLDS.small :
                      pairs <= 9 ? SCORE_CONFIG.STAR_THRESHOLDS.medium :
                      SCORE_CONFIG.STAR_THRESHOLDS.large;
    
    if (coins >= thresholds.three) return 3;
    if (coins >= thresholds.two) return 2;
    if (coins >= thresholds.one) return 1;
    return 0;
  }

  // =====================================
  // GESTI√ìN DEL MAPA
  // =====================================
  
  function themeForChapter(ch) {
    return THEMES[ch % THEMES.length];
  }
  
  function showMap(scrollToCurrent) {
    hide($('GameView'));
    hide($('StartView'));
    show($('MapView'));
    hide($('win'));
    hide($('fail'));
    hide($('noLives'));
    hide($('pause'));
    $('veil').classList.remove('show');
    
    // Aplicar tema del cap√≠tulo
    document.body.classList.remove('theme-0', 'theme-1', 'theme-2', 'theme-3', 'theme-4');
    document.body.classList.add(themeForChapter(currentChapter));
    
    const start = currentChapter * CHAPTER_SIZE + 1;
    const end = Math.min(LV.length, start + CHAPTER_SIZE - 1);
    $('chipInfo').textContent = `Tramo ${currentChapter + 1} ¬∑ Niveles ${start}‚Äì${end}`;
    
    const map = $('map');
    const svg = $('poly');
    map.innerHTML = '';
    svg.innerHTML = '';
    
    // Generar layout de nodos (zig-zag vertical)
    const nodes = buildNodesLayout(end - start + 1);
    
    // Crear l√≠nea de conexi√≥n
    const NS = "http://www.w3.org/2000/svg";
    const pl = document.createElementNS(NS, 'polyline');
    pl.setAttribute('fill', 'none');
    pl.setAttribute('stroke', 'var(--path)');
    pl.setAttribute('stroke-width', '6');
    pl.setAttribute('stroke-linecap', 'round');
    pl.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(pl);
    
    function recalc() {
      const w = svg.clientWidth;
      const h = svg.clientHeight;
      let pts = '';
      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        pts += (n.x / 100 * w) + ',' + (n.y / 100 * h) + ' ';
      }
      pl.setAttribute('points', pts.trim());
    }
    
    recalc();
    window.addEventListener('resize', recalc, { once: true });
    
    // Crear nodos
    for (let i = 0; i < nodes.length; i++) {
      const meta = LV[(start - 1) + i];
      if (!meta) continue;
      
      const n = nodes[i];
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'node';
      b.style.left = n.x + '%';
      b.style.top = n.y + '%';
      b.dataset.level = meta.id;
      
      const isBoss = (meta.id % CHAPTER_SIZE === 0) || meta.tags.includes('boss');
      const unlockedHere = meta.id <= unlocked;
      
      if (!unlockedHere) b.classList.add('lock');
      if (meta.id === unlocked) b.classList.add('current');
      if (meta.id < unlocked) b.classList.add('completed');
      
      if (isBoss) {
        b.classList.add('boss');
        b.innerHTML = '<span>' + meta.id + '</span><div class="icons">üëë</div><div class="label">BOSS</div>';
      } else {
        b.innerHTML = '<span>' + meta.id + '</span><div class="icons">' + iconsFor(meta) + '</div>';
      }
      
      b.onclick = () => {
        if (unlockedHere) {
          if (gameState.lives > 0) {
            startLevel(meta);
          } else {
            showModal('noLives');
            updateLifeTimer();
          }
        } else {
          showToast('üîí Nivel bloqueado');
        }
      };
      
      map.appendChild(b);
    }
    
    // Scroll al nivel actual si se solicita
    if (scrollToCurrent) {
      setTimeout(() => {
        const cur = map.querySelector('.node.current');
        if (cur) {
          cur.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        }
      }, 100);
    }
    
    // Actualizar navegaci√≥n
    const maxChap = Math.floor((LV.length - 1) / CHAPTER_SIZE);
    $('btnDown').disabled = currentChapter === 0;
    $('btnUp').disabled = currentChapter >= maxChap;
  }
  
  // Layout de nodos en zig-zag (m√°s aire entre nodos)
  function buildNodesLayout(count) {
    const arr = [];
    let y = 94;
    let left = true;
    
    for (let i = 0; i < count; i++) {
      arr.push({ id: i, x: (left ? 24 : 76), y: y });
      y -= ((i + 1) % 5 === 0 ? 4.2 : 2.2);
      left = !left;
    }
    
    return arr;
  }
  
  function iconsFor(meta) {
    let s = '';
    if (meta.t > 0) s += EMO.crono;
    
    ['niebla', 'barajar', 'triple', 'camaleon', 'trampa', 'bomba', 'comodin', 'fantasma', 'espejo'].forEach(t => {
      if (inTag(meta, t)) s += EMO[t];
    });
    
    if (meta.note && meta.note.indexOf('üî•') > -1) s += 'üî•';
    if (meta.note && meta.note.indexOf('üí§') > -1) s += 'üí§';
    if (meta.note && meta.note.indexOf('üëë') > -1) s += 'üëë';
    
    return s.split('').map(ch => '<span class="icon">' + ch + '</span>').join('');
  }

  // =====================================
  // L√ìGICA DEL JUEGO
  // =====================================
  
  function startLevel(lvl) {
    if (gameState.lives <= 0) {
      showModal('noLives');
      updateLifeTimer();
      return;
    }
    
    console.log('üéÆ Iniciando nivel', lvl.id, ':', lvl);
    
    // Reset del motor
    Engine.reset();
    Engine.time = lvl.t;
    Engine.tags = lvl.tags.slice();
    
    // Cargar plugins seg√∫n mec√°nicas
    if (lvl.t > 0) Engine.use(Plugins.crono);
    for (const tag of lvl.tags) {
      if (Plugins[tag]) Engine.use(Plugins[tag]);
    }
    
    // Cambiar a vista de juego
    hide($('MapView'));
    hide($('StartView'));
    show($('GameView'));
    hide($('win'));
    hide($('fail'));
    hide($('noLives'));
    hide($('pause'));
    $('veil').classList.remove('show');
    
    const matchSize = lvl.tags.indexOf('triple') > -1 ? 3 : 2;
    $('hudLevel').textContent = `Nivel ${lvl.id} ‚Äî ${lvl.pairs * matchSize} cartas`;
    
    renderBadges(lvl);
    $('hudTimer').textContent = (lvl.t > 0 ? fmt(lvl.t) : "");
    
    // Inicializar estado
    state = {
      lvl: lvl,
      firsts: [],
      matches: 0,
      timeLeft: lvl.t,
      raf: null,
      start: 0,
      iconsPool: ICONS.slice(),
      gridEl: $('grid'),
      turnLocked: false,
      espejoTimer: null,
      engine: Engine,
      movesUsed: 0,
      fails: 0,
      bombasActivadas: 0
    };
    
    state.gridEl.innerHTML = '';
    
    // Generar cartas con selecci√≥n determinista
    let ids = [];
    for (let u = 0; u < lvl.pairs; u++) {
      for (let k = 0; k < matchSize; k++) {
        ids.push(u);
      }
    }
    
    // Barajar con seed determinista
    const rng = RNG(lvl.seed || (GLOBAL_SEED + lvl.id));
    shuffleWithRNG(ids, rng);
    
    // Configurar grid responsivo
    const cols = Math.ceil(Math.sqrt(ids.length));
    state.gridEl.className = `grid grid-${Math.min(cols, 6)}`;
    
    // Crear cartas
    for (let i2 = 0; i2 < ids.length; i2++) {
      const c = document.createElement('button');
      c.type = 'button';
      c.className = 'card';
      c.setAttribute('data-id', ids[i2]);
      c.setAttribute('data-idx', i2);
      c.textContent = '‚ùì';
      c.onclick = () => onCard(c, matchSize);
      state.gridEl.appendChild(c);
    }
    
    // Ejecutar hooks de inicio
    for (const h of Engine.hooks.onStart) {
      h(ctx());
    }
    
    // Iniciar cron√≥metro si es necesario
    if (lvl.t > 0) {
      state.start = performance.now();
      const start = state.start;
      
      function tick(now) {
        const elapsed = Math.floor((now - start) / 1000);
        const rem = Math.max(0, lvl.t - elapsed - (state._pen || 0));
        state.timeLeft = rem;
        
        for (const h of Engine.hooks.onTick) {
          h(ctx(), now, elapsed, rem);
        }
        
        if (rem <= 0) {
          cancelAnimationFrame(state.raf);
          return;
        }
        
        state.raf = requestAnimationFrame(tick);
      }
      
      state.raf = requestAnimationFrame(tick);
    } else {
      hide($('barWrap'));
    }
    
    // Actualizar contadores
    updateGameStats();
    
    playSound('start');
  }
  
  function renderBadges(lvl) {
    const wrap = $('hudBadges');
    wrap.innerHTML = '';
    
    const list = [];
    if (lvl.t > 0) list.push('crono');
    
    ['niebla', 'barajar', 'triple', 'camaleon', 'trampa', 'bomba', 'comodin', 'fantasma', 'espejo'].forEach(t => {
      if (lvl.tags.indexOf(t) > -1) list.push(t);
    });
    
    if (lvl.note && lvl.note.indexOf('üëë') > -1) list.push('boss');
    
    list.forEach(t => {
      const b = document.createElement('span');
      b.className = 'badge';
      b.innerHTML = '<span>' + EMO[t] + '</span><span>' + t + '</span>';
      wrap.appendChild(b);
    });
  }
  
  function onCard(card, matchSize) {
    if (state.turnLocked) return;
    if (card.classList.contains('matched') || card.classList.contains('flip')) return;
    
    // Ejecutar hooks de flip
    for (const h of Engine.hooks.onFlip) {
      h(ctx(), card);
    }
    
    flipUp(card, ctx());
    state.firsts.push(card);
    state.movesUsed++;
    updateGameStats();
    
    if (state.firsts.length === matchSize) {
      const ok = isMatch(state.firsts);
      
      if (ok) {
        // ¬°Match encontrado!
        for (const c of state.firsts) {
          c.classList.add('matched');
        }
        
        state.matches++;
        state.firsts.length = 0;
        
        for (const h2 of Engine.hooks.onMatch) {
          h2(ctx(), card, null, null);
        }
        
        playSound('match');
        createParticles('‚ú®', card);
        
        // Verificar victoria
        if (state.matches === state.lvl.pairs) {
          return win();
        }
      } else {
        // Fallo
        state.fails++;
        const A = state.firsts.slice();
        state.firsts.length = 0;
        
        // Marcar cartas como incorrectas
        A.forEach(c => c.classList.add('wrong'));
        
        setTimeout(() => {
          A.forEach(c => {
            flipDown(c);
            c.classList.remove('wrong');
          });
          
          for (const h3 of Engine.hooks.onMismatch) {
            h3(ctx());
          }
        }, 500);
        
        playSound('fail');
        updateGameStats();
      }
    }
  }
  
  function isMatch(cards) {
    // Verificar comodines
    for (const c of cards) {
      if (c.dataset.isWild === '1') return true;
    }
    
    // Verificar que todos tengan el mismo data-id
    const id0 = cards[0].getAttribute('data-id');
    for (let j = 1; j < cards.length; j++) {
      if (cards[j].getAttribute('data-id') !== id0) return false;
    }
    
    return true;
  }
  
  function flipUp(c, ctx) {
    c.classList.add('flip');
    const id = parseInt(c.getAttribute('data-id'), 10);
    const iconOverride = c.dataset.iconOverride;
    c.textContent = iconOverride ? iconOverride : state.iconsPool[id % state.iconsPool.length];
  }
  
  function flipDown(c) {
    c.classList.remove('flip');
    c.textContent = '‚ùì';
    delete c.dataset.iconOverride;
  }
  
  function reshuffleSome(grid, count) {
    const nodes = [...grid.children].filter(el => !el.classList.contains('matched'));
    if (nodes.length < 4) return;
    
    shuffle(nodes);
    const take = nodes.slice(0, Math.min(count, nodes.length));
    
    for (const n of take) {
      grid.removeChild(n);
    }
    
    shuffle(take);
    
    for (const n of take) {
      grid.appendChild(n);
    }
  }
  
  function shuffleIcons(ctx) {
    const cells = [...state.gridEl.children].filter(el => 
      el.classList.contains('flip') && !el.classList.contains('matched')
    );
    
    shuffle(cells);
    
    for (const c of cells) {
      const id = parseInt(c.getAttribute('data-id'), 10);
      c.textContent = state.iconsPool[(id + Math.floor(Math.random() * state.iconsPool.length)) % state.iconsPool.length];
    }
  }
  
  function win() {
    cancelAnimationFrame(state.raf);
    $('veil').classList.remove('show');
    
    const timeUsed = state.lvl.t > 0 ? 
      Math.floor((performance.now() - state.start) / 1000) : 
      Math.floor((Date.now() - state.start) / 1000);
    
    // Calcular puntuaci√≥n
    const result = calculateCoins(state.lvl, timeUsed, state.movesUsed, state.fails, state.bombasActivadas);
    const stars = calculateStars(result.coins, state.lvl.pairs);
    
    // Solo sumar si supera r√©cord personal
    const levelKey = state.lvl.id;
    const previousBest = gameState.levelRecords[levelKey]?.bestCoins || 0;
    
    if (result.coins > previousBest) {
      const coinsDiff = result.coins - previousBest;
      gameState.coins += coinsDiff;
      
      // Guardar nuevo r√©cord
      gameState.levelRecords[levelKey] = {
        bestCoins: result.coins,
        bestTime: timeUsed,
        bestMoves: state.movesUsed,
        stars: stars,
        date: Date.now()
      };
      
      console.log(`üèÜ ¬°Nuevo r√©cord en nivel ${levelKey}! +${coinsDiff} monedas`);
    }
    
    // Actualizar progreso
    if (unlocked < state.lvl.id + 1) {
      unlocked = state.lvl.id + 1;
      gameState.maxLevelUnlocked = unlocked;
    }
    
    saveUserData();
    updateUI();
    
    // Mostrar breakdown de puntuaci√≥n
    showVictoryModal(result, stars);
    
    // Transici√≥n autom√°tica si es boss
    const wasBoss = (state.lvl.id % 50 === 0);
    if (wasBoss) {
      const nextChapter = Math.floor((state.lvl.id) / 50);
      if (nextChapter > currentChapter) {
        currentChapter = nextChapter;
        transitionUp();
      }
    }
    
    playSound('victory');
    createParticles('üéâ');
  }
  
  function fail() {
    cancelAnimationFrame(state.raf);
    $('veil').classList.remove('show');
    
    // Restar vida solo en derrota
    gameState.lives = Math.max(0, gameState.lives - 1);
    localStorage.setItem('memoflip_last_life_regen', Date.now().toString());
    
    saveUserData();
    updateUI();
    
    if (gameState.lives > 0) {
      $('remainingLives').textContent = gameState.lives;
      show($('fail'));
    } else {
      showModal('noLives');
      updateLifeTimer();
    }
    
    playSound('defeat');
  }
  
  function showVictoryModal(result, stars) {
    $('victoryLevel').textContent = state.lvl.id;
    
    const breakdown = $('scoreBreakdown');
    breakdown.innerHTML = `
      <div class="score-line">
        <span>Base (${state.lvl.pairs} parejas):</span>
        <span>+${result.breakdown.base}</span>
      </div>
      <div class="score-line">
        <span>Bonus tiempo:</span>
        <span>+${result.breakdown.timeBonus}</span>
      </div>
      <div class="score-line">
        <span>Bonus eficiencia:</span>
        <span>+${result.breakdown.effBonus}</span>
      </div>
      <div class="score-line">
        <span>Penalizaciones:</span>
        <span>-${result.breakdown.penalties}</span>
      </div>
      <div class="score-line">
        <span>Multiplicador:</span>
        <span>√ó${result.breakdown.mult}</span>
      </div>
      <div class="score-line score-total">
        <span>Total:</span>
        <span>${result.coins} ü™ô</span>
      </div>
      <div class="score-line">
        <span>Estrellas:</span>
        <span>${'‚≠ê'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)}</span>
      </div>
    `;
    
    show($('win'));
  }

  // =====================================
  // EVENTOS Y CONTROLES
  // =====================================
  
  // Eventos de botones
  $('btnStartGuest').onclick = () => {
    gameState.currentUser = 'guest_' + Date.now();
    gameState.isGuest = true;
    saveUserData();
    updateUI();
    
    // Ir directo al √∫ltimo nivel desbloqueado seg√∫n especificaci√≥n
    currentChapter = Math.floor((unlocked - 1) / CHAPTER_SIZE);
    showMap(true);
  };
  
  $('btnLogin').onclick = () => showToast('üöß Login pr√≥ximamente disponible');
  $('btnRegister').onclick = () => showToast('üöß Registro pr√≥ximamente disponible');
  $('btnShowMap').onclick = () => {
    currentChapter = Math.floor((unlocked - 1) / CHAPTER_SIZE);
    showMap(true);
  };
  
  // Navegaci√≥n del mapa
  $('btnUp').onclick = () => {
    const maxChap = Math.floor((LV.length - 1) / CHAPTER_SIZE);
    if (currentChapter < maxChap) {
      currentChapter++;
      transitionUp();
      showMap(true);
    }
  };
  
  $('btnDown').onclick = () => {
    if (currentChapter > 0) {
      currentChapter--;
      transitionDown();
      showMap(true);
    }
  };
  
  // Controles de juego
  $('btnPause').onclick = () => {
    if (state.raf) cancelAnimationFrame(state.raf);
    show($('pause'));
  };
  
  $('btnResume').onclick = () => {
    hide($('pause'));
    if (state.lvl.t > 0 && state.timeLeft > 0) {
      state.start = performance.now() - (state.lvl.t - state.timeLeft) * 1000;
      const start = state.start;
      
      function tick(now) {
        const elapsed = Math.floor((now - start) / 1000);
        const rem = Math.max(0, state.lvl.t - elapsed - (state._pen || 0));
        state.timeLeft = rem;
        
        for (const h of Engine.hooks.onTick) {
          h(ctx(), now, elapsed, rem);
        }
        
        if (rem <= 0) {
          cancelAnimationFrame(state.raf);
          return;
        }
        
        state.raf = requestAnimationFrame(tick);
      }
      
      state.raf = requestAnimationFrame(tick);
    }
  };
  
  // Botones de modales
  $('btnNextLevel').onclick = () => {
    hide($('win'));
    const nextId = state.lvl ? state.lvl.id + 1 : 1;
    if (unlocked < nextId) unlocked = nextId;
    const nx = getLevelById(nextId);
    nx ? startLevel(nx) : showMap(true);
  };
  
  $('btnRetry').onclick = () => {
    hide($('fail'));
    startLevel(state.lvl);
  };
  
  $('btnRetryWin').onclick = () => {
    hide($('win'));
    startLevel(state.lvl);
  };
  
  $('btnRetryPause').onclick = () => {
    hide($('pause'));
    startLevel(state.lvl);
  };
  
  // Botones para volver al mapa
  $('btnMapWin').onclick = () => showMap(true);
  $('btnMapFail').onclick = () => showMap(true);
  $('btnMapPause').onclick = () => showMap(true);
  $('btnMapNoLives').onclick = () => showMap(true);
  
  // Sonido
  $('soundToggle').onclick = () => {
    gameState.soundEnabled = !gameState.soundEnabled;
    saveUserData();
    updateUI();
    playSound('click');
  };

  // =====================================
  // FUNCIONES AUXILIARES
  // =====================================
  
  function getLevelById(id) {
    return LV.find(x => x.id === id) || null;
  }
  
  function inTag(meta, t) {
    return meta.tags && meta.tags.indexOf(t) > -1;
  }
  
  function ctx() {
    return {
      lvl: state.lvl,
      gridEl: state.gridEl,
      iconsPool: state.iconsPool,
      timeLeft: state.timeLeft,
      engine: Engine,
      fail: fail
    };
  }
  
  function transitionUp() {
    const wrap = $('mapWrap');
    wrap.classList.add('fadeUp');
    setTimeout(() => wrap.classList.remove('fadeUp'), 280);
  }
  
  function transitionDown() {
    const wrap = $('mapWrap');
    wrap.classList.add('fadeUp');
    setTimeout(() => wrap.classList.remove('fadeUp'), 280);
  }
  
  function shuffleWithRNG(array, rng) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(rng() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  
  function updateGameStats() {
    $('movesDisplay').textContent = state.movesUsed;
    $('failsDisplay').textContent = state.fails;
  }
  
  function updateLifeTimer() {
    const updateTimer = () => {
      const now = Date.now();
      const lastRegen = parseInt(localStorage.getItem('memoflip_last_life_regen') || now);
      const timeSinceRegen = now - lastRegen;
      const timeForNextLife = (60 * 60 * 1000) - (timeSinceRegen % (60 * 60 * 1000));
      
      if (timeSinceRegen >= 60 * 60 * 1000 && gameState.lives < 5) {
        gameState.lives = Math.min(5, gameState.lives + 1);
        localStorage.setItem('memoflip_last_life_regen', now.toString());
        saveUserData();
        updateUI();
        
        if (gameState.lives > 0) {
          hide($('noLives'));
          showToast('‚ù§Ô∏è ¬°Vida regenerada!');
          return;
        }
      }
      
      const minutes = Math.floor(timeForNextLife / (60 * 1000));
      const seconds = Math.floor((timeForNextLife % (60 * 1000)) / 1000);
      
      const timerElement = $('nextLifeTimer');
      if (timerElement) {
        timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      setTimeout(updateTimer, 1000);
    };
    
    updateTimer();
  }

  // =====================================
  // UI Y EFECTOS
  // =====================================
  
  function updateUI() {
    $('coinsDisplay').textContent = gameState.coins.toLocaleString();
    $('livesDisplay').textContent = gameState.lives;
    $('soundToggle').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
  }
  
  function showModal(modalId) {
    hideAllModals();
    show($(modalId));
  }
  
  function hideAllModals() {
    hide($('win'));
    hide($('fail'));
    hide($('noLives'));
    hide($('pause'));
  }
  
  function showToast(message, duration = 3000) {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      color: var(--ink);
      padding: 0.8rem 1.2rem;
      border-radius: 0.5rem;
      border: 1px solid var(--muted);
      z-index: 1000;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-size: clamp(12px, 3vw, 14px);
      max-width: 90vw;
      text-align: center;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, duration);
  }
  
  function createParticles(emoji, targetElement = null) {
    const container = document.createElement('div');
    container.style.cssText = 'position: fixed; inset: 0; pointer-events: none; z-index: 150;';
    document.body.appendChild(container);
    
    const rect = targetElement ? targetElement.getBoundingClientRect() : 
      { left: window.innerWidth / 2, top: window.innerHeight / 2 };
    
    for (let i = 0; i < 6; i++) {
      const particle = document.createElement('div');
      particle.style.cssText = `
        position: absolute;
        font-size: clamp(1rem, 4vw, 1.5rem);
        animation: particle-float 2s ease-out forwards;
        left: ${rect.left + Math.random() * 40 - 20}px;
        top: ${rect.top + Math.random() * 40 - 20}px;
      `;
      particle.textContent = emoji;
      container.appendChild(particle);
    }
    
    setTimeout(() => {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
    }, 2000);
  }
  
  function playSound(type) {
    if (!gameState.soundEnabled) return;
    
    // Implementaci√≥n b√°sica de sonidos
    console.log(`üîä Sonido: ${type}`);
    
    // TODO: Implementar sonidos reales con Web Audio API
    // flip, match, fail, victory, defeat, start, pause, resume, etc.
  }

  // =====================================
  // INICIALIZACI√ìN
  // =====================================
  
  // Cargar datos de usuario
  loadUserData();
  
  // Generar niveles
  LV = buildLevels(TOTAL_LEVELS, GLOBAL_SEED);
  console.log(`üìö Generados ${LV.length} niveles`);
  
  // Configurar cap√≠tulo inicial seg√∫n √∫ltimo nivel desbloqueado
  currentChapter = Math.floor((unlocked - 1) / CHAPTER_SIZE);
  
  // Actualizar UI inicial
  updateUI();
  
  // Mostrar pantalla de inicio
  show($('StartView'));
  
  console.log('‚úÖ MemoFlip v2 iniciado correctamente');
  console.log(`üìç √öltimo nivel desbloqueado: ${unlocked}`);
  console.log(`üìñ Cap√≠tulo actual: ${currentChapter + 1}`);
});

// Estilos din√°micos para part√≠culas
const style = document.createElement('style');
style.textContent = `
@keyframes particle-float {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-100px) scale(0.5); opacity: 0; }
}
`;
document.head.appendChild(style);
</script>
</body>
</html>
